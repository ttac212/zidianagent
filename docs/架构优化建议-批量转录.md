# 批量转录功能架构优化建议

## 当前架构

### 调用链路
```
batch-transcribe/stream/route.ts (服务器端)
  └─> HTTP fetch -> /api/douyin/extract-text (服务器端)
        └─> 下载视频 (耗时)
        └─> 提取音频 (耗时)
        └─> ASR转录 (耗时)
        └─> LLM优化 (耗时)
```

### 存在的问题

1. **HTTP回环开销**
   - API Route A 通过 HTTP 调用 API Route B
   - 即使是同域回环，也需要序列化/反序列化、建立连接
   - 无法共享内存、状态

2. **无法水平扩展**
   - 批量转录时，每个视频都发起独立的HTTP请求
   - 并发受限于单个服务器实例
   - 无法利用多核/多实例优势

3. **错误处理复杂**
   - 需要处理HTTP层错误 + 业务层错误
   - SSE流式响应嵌套在HTTP响应中

## 推荐优化方案

### 方案A: 直接复用内部Pipeline（推荐）

```typescript
// app/api/merchants/[id]/contents/batch-transcribe/stream/route.ts

import { runDouyinPipeline } from '@/lib/douyin/pipeline-steps'

async function transcribeContent(
  contentId: string,
  merchantId: string,
  apiKey: string
): Promise<TranscribeResult> {
  // ...获取 shareUrl 逻辑保持不变...

  // 直接调用内部 pipeline，不经过 HTTP
  let finalText = ''

  await runDouyinPipeline(
    content.shareUrl,
    async (event) => {
      if (event.type === 'done' && event.markdown) {
        finalText = event.markdown
      }
    },
    { signal: AbortSignal.timeout(300000) }
  )

  // ...后续更新数据库逻辑保持不变...
}
```

**优势**:
- 消除HTTP回环开销
- 共享内存，减少序列化
- 更简洁的错误处理
- 可以直接控制并发（使用p-limit等库）

**改动范围**:
- 仅需修改 `batch-transcribe/stream/route.ts` 的 `transcribeContent` 函数
- 移除 `fetch()` 调用，直接引入 `runDouyinPipeline`

### 方案B: 任务队列异步处理

如果需要支持大规模批量转录（100+视频），可以考虑引入任务队列:

```typescript
// 使用 BullMQ + Redis
import { Queue, Worker } from 'bullmq'

const transcribeQueue = new Queue('video-transcribe', {
  connection: redisConnection
})

// API Route 只负责入队
await transcribeQueue.addBulk(
  contentIds.map(id => ({
    name: 'transcribe',
    data: { contentId, merchantId }
  }))
)

// Worker 进程处理实际转录
const worker = new Worker('video-transcribe', async (job) => {
  await runDouyinPipeline(...)
})
```

**优势**:
- 真正的异步处理，不阻塞HTTP请求
- 可以水平扩展Worker数量
- 支持重试、优先级、延迟执行
- 可以在多台服务器间分布

**劣势**:
- 需要引入Redis依赖
- 实时进度反馈需要额外机制（WebSocket/轮询）
- 架构复杂度增加

## 实施建议

### 短期（1-2天）
- 实施方案A：直接复用内部Pipeline
- 消除HTTP回环，提升性能20-30%
- 改动小，风险低

### 中期（1-2周）
- 评估批量转录的实际使用场景
- 如果单次转录视频数 < 50，方案A足够
- 如果需要支持100+视频，考虑方案B

### 长期（1个月+）
- 监控转录任务的失败率、耗时分布
- 考虑是否需要引入专门的媒体处理服务
- 评估是否需要支持断点续传、增量同步

## 风险评估

| 风险项 | 当前架构 | 方案A | 方案B |
|--------|---------|-------|-------|
| HTTP超时 | 高 | 低 | 无 |
| 内存占用 | 中 | 中 | 低 |
| 实现复杂度 | 中 | 低 | 高 |
| 部署复杂度 | 低 | 低 | 高 |
| 可扩展性 | 低 | 中 | 高 |

## 相关文件

- `app/api/merchants/[id]/contents/batch-transcribe/stream/route.ts` - 批量转录入口
- `app/api/douyin/extract-text/route.ts` - 单个视频转录（可能被废弃）
- `lib/douyin/pipeline-steps.ts` - 核心Pipeline逻辑
- `lib/video/video-processor.ts` - 视频下载/音频提取

## 更新日志

- 2025-01-12: 创建文档，记录当前架构问题和优化方向
