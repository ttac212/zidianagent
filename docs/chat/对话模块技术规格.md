## 对话模块技术规格（实施级）

### 1. 范围与定位

- 本规格覆盖“对话（Chat）”模块：前端 UI/状态/逻辑、与后端 `/api/chat` 的对接、模型选择白名单，以及对话历史的本地管理。
- 当前主用实现：
  - 容器组件：components/chat/smart-chat-center-v2-fixed.tsx（导出别名 SmartChatCenterV2）
  - 子组件：ChatHeader、ChatMessages、ChatInput、ModelSelectorAnimated、MessageItem、TypingIndicator
  - Hooks：use-chat-state、use-chat-actions-fixed、use-chat-effects、use-conversations
  - 类型：types/chat.ts
  - 模型白名单/默认：lib/ai/models.ts
  - 服务端：app/api/chat/route.ts

非目标：
- 简化示例 components/chat/simple-chat-box.tsx 仅作演示；非生产路径。

---

### 2. 架构概览与数据流

- 单向数据流（容器持有状态）：
  - SmartChatCenterV2Fixed 管理聊天状态（use-chat-state）与动作（use-chat-actions-fixed），提供副作用（use-chat-effects）。
  - ChatHeader 展示与操作当前对话（标题编辑、新建、导出、删除）。
  - ChatMessages 渲染消息列表与“正在输入”指示器。
  - ChatInput 控制输入、发送/停止、模型选择。
- 与历史的交互：
  - use-conversations 负责本地存储的会话列表、当前会话 ID 与 CRUD。
  - 切换会话时，仅在 conversation.id 变化时同步消息入本地状态，避免循环。
- 与后端：
  - use-chat-actions-fixed 通过 fetch POST /api/chat 发起请求，读取 ReadableStream，逐行解析 SSE data: 行，使用 UPDATE_MESSAGE 增量更新助手消息。

数据流关键片段（容器将新会话消息同步到本地状态）：
<augment_code_snippet path="components/chat/smart-chat-center-v2-fixed.tsx" mode="EXCERPT">
````tsx
useEffect(() => {
  if (conversation?.id && conversation.messages) {
    dispatch({ type: 'CLEAR_MESSAGES' })
    conversation.messages.forEach(msg => {
      dispatch({ type: 'ADD_MESSAGE', payload: msg })
    })
  } else if (!conversation?.id) {
    dispatch({ type: 'CLEAR_MESSAGES' })
  }
}, [conversation?.id])
````
</augment_code_snippet>

---

### 3. 前端模块分解与职责

#### 3.1 状态与类型（types/chat.ts）

- ChatMessage：{ id, role: 'user'|'assistant', content, timestamp, tokens?, metadata? }
- ChatSettings：模型/温度/上下文感知等
- ChatState：消息数组、输入框内容、加载态、错误、设置、标题编辑态
- Reducer Action 集合：SET_INPUT、SET_LOADING、SET_ERROR、ADD_MESSAGE、UPDATE_MESSAGE、CLEAR_MESSAGES、SET_SETTINGS、SET_EDITING_TITLE、SET_TEMP_TITLE、RESET_STATE
- 默认设置与状态以 DEFAULT_ 常量导出，不允许随意更改键名

示例（更新消息的唯一正规途径）：
<augment_code_snippet path="hooks/use-chat-state.ts" mode="EXCERPT">
````ts
case 'UPDATE_MESSAGE':
  return {
    ...state,
    messages: state.messages.map(msg =>
      msg.id === action.payload.id
        ? { ...msg, ...action.payload.updates }
        : msg
    )
  }
````
</augment_code_snippet>

示例（设置定义和默认值）：
<augment_code_snippet path="types/chat.ts" mode="EXCERPT">
````ts
export interface ChatSettings {
  modelId: string
  temperature: number
  contextAware: boolean
  maxTokens?: number
  systemPrompt?: string
}
````
</augment_code_snippet>

不变量：
- role 枚举仅 'user'|'assistant'
- ChatSettings.modelId 必须是白名单中的“模型ID”（非友好名）
- 任何 UI 渲染、流式增量写入、历史同步，必须通过 reducer action，而非直接 mutate

#### 3.2 容器组件（SmartChatCenterV2Fixed）

- 负责：
  - 初始化设置（从 ALLOWED_MODELS 和传入 selectedModel 推导 modelId）
  - 承载 state、actions、effects
  - 将选中文本 selectedText 注入输入框
  - 与对话管理回调（onUpdateConversation/onCreateConversation/...）
- 交互：
  - 发送：调用 actions.sendMessage；成功后清空输入
  - 模型更改：updateSettings，并通过 onSelectedModelChange 回调上抛
  - 标题编辑：本地 UI 态配合 onUpdateConversation 持久化

#### 3.3 输入组件（ChatInput）

- 受控组件，props：input、isLoading、settings、onInputChange、onSubmit、onStop、onSettingsChange、selectedText（可选）
- 快捷键：
  - Enter 发送（Shift+Enter 换行）
  - Escape 停止生成
- 内含模型选择器 ModelSelectorAnimated；对模型 ID 进行回填更新

关键行为（防止回归）：
<augment_code_snippet path="components/chat/chat-input.tsx" mode="EXCERPT">
````tsx
const handleKeyDown = (e: React.KeyboardEvent) => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (input.trim() && !isLoading) onSubmit(e as any) }
  if (e.key === 'Escape') { onStop() }
}
````
</augment_code_snippet>

#### 3.4 消息列表（ChatMessages）与消息项（MessageItem）

- ChatMessages 通过 useMemo 将 messages 渲染为多个 MessageItem，包含 onCopy、onRetry
- 空态与错误态处理：当 error 且无历史消息时渲染 ErrorState；非空态优先显示消息

#### 3.5 副作用 Hook（use-chat-effects）

- 滚动管理：新消息出现后自动滚动至底部（通过 ScrollArea 视口选择器）
- 聚焦管理：加载完成或错误时聚焦输入框
- 全局快捷键：
  - Ctrl+Enter 或输入框内 Enter（非 Shift）发送
  - Escape 停止
  - Ctrl+N 新建对话
  - Ctrl+L 聚焦输入
  - Ctrl+K 清空消息（带确认）
- 对外暴露 textareaRef、scrollAreaRef 给容器透传至子组件

#### 3.6 动作 Hook（use-chat-actions-fixed）

- 作用：封装发送消息、停止生成、复制、重试、清空、更新设置、批处理等
- 发送流程：
  1) 本地添加用户消息（ADD_MESSAGE）
  2) 发起 fetch('/api/chat')，携带 messages、model、temperature
  3) 创建空的助手消息并 ADD_MESSAGE
  4) 读取 ReadableStream，逐行解析 SSE 的 data: JSON 块，累积 content，持续 UPDATE_MESSAGE
  5) 结束后落盘对话（如果容器提供 onUpdateConversation）

流式解析关键（不要改动结构，否则会断流/丢字）：
<augment_code_snippet path="hooks/use-chat-actions-fixed.ts" mode="EXCERPT">
````ts
const { done, value } = await reader.read()
const chunk = new TextDecoder().decode(value)
const lines = chunk.split('\n')
for (const line of lines) {
  if (line.startsWith('data: ') && line !== 'data: [DONE]') {
    const data = JSON.parse(line.slice(6))
    const content = data.choices?.[0]?.delta?.content
    if (content) dispatch({ type:'UPDATE_MESSAGE', payload:{ id:assistantMessage.id, updates:{ content: assistantContent += content }}})
  }
}
````
</augment_code_snippet>

- 停止生成：内部使用 AbortController 中断 fetch；isLoading 必须即时还原，助手消息保留已累积内容（不可丢弃）

---

### 4. 模型选择与白名单（lib/ai/models.ts）

- ALLOWED_MODEL_IDS 来自环境变量 MODEL_ALLOWLIST（逗号分隔），或默认回退列表
- ALLOWED_MODELS 提供 {id, name} 给前端展示；但“对接后端与状态”一律使用 id
- DEFAULT_MODEL = ALLOWED_MODEL_IDS[0]

不变量：
- UI 仅展示 ALLOWED_MODELS；变更 .env 后需刷新构建并验证列表
- 前端永远使用 modelId = 真实模型 ID；禁止以“友好名”作为 ID 上送

---

### 5. 后端 API 合同（app/api/chat/route.ts）

- Endpoint：POST /api/chat
- 入参 JSON：
  - messages: Array<{role: 'user'|'assistant'|...; content: string}>
  - model: string（必须为白名单 ID）
  - temperature?: number
  - editorExcerpt?: string（可选，作为 system 消息注入最前）
- 校验：非白名单模型直接 400，并返回 allowedModels
<augment_code_snippet path="app/api/chat/route.ts" mode="EXCERPT">
````ts
if (!isAllowed(model)) {
  return new Response(JSON.stringify({ error: `模型 "${model}" 不在白名单内，请联系管理员配置。`, allowedModels: ALLOWED_MODEL_IDS }), { status: 400, headers: { "Content-Type": "application/json" }})
}
````
</augment_code_snippet>

- 对接上游：默认走 OpenAI 兼容的 /chat/completions，开启 stream: true
<augment_code_snippet path="app/api/chat/route.ts" mode="EXCERPT">
````ts
const base = (process.env.LLM_API_BASE || "https://api.302.ai/v1").replace(/\/$/, "")
let endpoint = `${base}/chat/completions`
const payload = { model: useModel, messages: finalMessages, stream: true }
````
</augment_code_snippet>

- SSE 透传：以 data: ... 分块返回（前端按上述解析）
- 环境变量：
  - LLM_API_KEY，LLM_API_BASE（302.AI 聚合）
  - MODEL_ALLOWLIST（供前端列表与后端校验）

---

### 6. 对话历史管理（hooks/use-conversations.ts）

- 本地存储键：
  - STORAGE_KEYS.CONVERSATIONS（列表）
  - current_conversation_id
- 对话结构：{ id, title, messages, model, createdAt, updatedAt }
- 行为：create/update/delete/setCurrent/clearAll
- 与容器联动：容器在切换会话时重放消息、在消息结束时可 onUpdateConversation 对话的 messages 与 title 做持久化更新

---

### 7. 不变量与“不可破坏”契约

- 消息类型与 reducer action 名称不得随意改动；如需增量扩展，需兼容已有分支
- 流式解析的“行前缀 + JSON 格式 + choices[0].delta.content”契约不可破坏
- modelId 必须来自白名单 ID；严禁用友好名上送
- 停止生成必须以 AbortController 执行；不允许通过关闭组件或清空引用来“假停止”
- ChatInput 的 Enter/Shift+Enter/Escape 行为不可改变（属于用户肌肉记忆与快捷键契约）
- use-chat-effects 的 ScrollArea 选择器 data-radix-scroll-area-viewport 的 DOM 结构依赖不可随意替换；如需替换滚动容器，必须同步更新选择器逻辑
- 切换会话仅在 conversation.id 变化时重放消息，避免无限循环或重复叠加

---

### 8. 可扩展点与安全改动指引

- 在不影响契约的前提下，允许的扩展：
  - 添加 MessageMetadata 字段（如评分、工具调用摘要）；务必保持渲染容错
  - 扩展 ChatSettings（如 top_p、presence_penalty）；务必在后端转换时与上游参数对应，且默认值回退良好
  - 在 ChatHeader 增添操作项（分享、归档）；避免阻塞 Dropdown/AlertDialog 的行为链
  - 替换 ModelSelectorAnimated 的视觉表现；但 props 与 onChange(modelId: string) 契约保持不变
- 常见“安全变更配方”：
  1) 调整占位文案/样式：限于 ChatInput/ChatMessages 文本与 className，不改事件绑定与键值
  2) 添加错误提示：通过 state.error 渲染，勿改变错误设置路径（SET_ERROR）
  3) 增加系统提示词：在后端 route.ts 注入 system 消息（保持在消息数组首位）

---

### 9. 禁止事项与常见陷阱

- 禁止将 ALLOWED_MODELS 的 name 用作请求的 model；必须传 id
- 禁止将流式解析改为“整段 JSON 再渲染”；会丢失进度与打断停止
- 禁止在 useEffect 中基于“state.messages”去写回“conversation.messages”；会造成循环
- 禁止直接 mutate state.messages（必须通过 reducer）
- 注意 Windows 终端下 curl JSON 转义问题，导致后端 JSON 解析失败——联调建议用 Node fetch/浏览器

---

### 10. 回归测试与验收清单

功能冒烟
- 模型选择下拉显示白名单中模型名，选择后发起请求的 model 值为 ID
- Enter 发送、Shift+Enter 换行；Escape 可中断流式返回
- 发送中显示 Loading 与 Stop 按钮；中断后 isLoading 复原
- 流式渲染：可见助手消息逐字增长，结束后对话历史落盘
- 切换会话：仅重放所选会话消息，不叠加、不闪烁

错误场景
- 使用非白名单模型：前端收到 400，展示错误提示；允许用户重试
- 无 LLM_API_KEY：后端 500，前端展示可理解的错误态并可继续发送其他请求

自动化建议
- Reducer 单元测试：ADD/UPDATE/CLEAR/SET_SETTINGS 等分支
- SSE 解析集成测试：伪造 data: 流，验证 UPDATE_MESSAGE 合成文本
- 快捷键 E2E：Enter/Shift+Enter/Escape/Ctrl+N/Ctrl+L/Ctrl+K
- 视图测试：滚动到底部逻辑在新增消息时触发

---

### 11. 参考代码摘录（关键契约片段）

- ChatSettings（类型契约）
<augment_code_snippet path="types/chat.ts" mode="EXCERPT">
````ts
export interface ChatSettings {
  modelId: string
  temperature: number
  contextAware: boolean
  maxTokens?: number
  systemPrompt?: string
}
````
</augment_code_snippet>

- Reducer 更新消息（唯一通道）
<augment_code_snippet path="hooks/use-chat-state.ts" mode="EXCERPT">
````ts
case 'UPDATE_MESSAGE':
  return {
    ...state,
    messages: state.messages.map(msg =>
      msg.id === action.payload.id ? { ...msg, ...action.payload.updates } : msg
    )
  }
````
</augment_code_snippet>

- 输入法快捷键（Enter/Escape 契约）
<augment_code_snippet path="components/chat/chat-input.tsx" mode="EXCERPT">
````tsx
if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (input.trim() && !isLoading) onSubmit(e as any) }
if (e.key === 'Escape') { onStop() }
````
</augment_code_snippet>

- SSE 解析（data: + delta.content 契约）
<augment_code_snippet path="hooks/use-chat-actions-fixed.ts" mode="EXCERPT">
````ts
if (line.startsWith('data: ') && line !== 'data: [DONE]') {
  const data = JSON.parse(line.slice(6))
  const content = data.choices?.[0]?.delta?.content
  if (content) dispatch({ type:'UPDATE_MESSAGE', payload:{ id:assistantMessage.id, updates:{ content: assistantContent += content }}})
}
````
</augment_code_snippet>

- 后端白名单校验（模型 ID 契约）
<augment_code_snippet path="app/api/chat/route.ts" mode="EXCERPT">
````ts
if (!isAllowed(model)) {
  return new Response(JSON.stringify({ error: `模型 "${model}" 不在白名单内，请联系管理员配置。`, allowedModels: ALLOWED_MODEL_IDS }), { status: 400, headers: { "Content-Type": "application/json" }})
}
````
</augment_code_snippet>

---

### 12. 变更管理与文档化要求

- 任何影响上述契约的改动（类型、快捷键、SSE 解析、模型 ID 处理、reducer action 名称等）必须在提交前更新本技术规格，并配套测试。
- UI-only 改动（样式/文案）无需更新契约，但应进行冒烟。
- 建议与以下文档互链：
  - CHAT_IMPLEMENTATION_BACKUP.md（实现备份与现状）
  - docs/对话功能实施记录/（每日记录）

---

## 待确认：保存位置与文件名

建议保存路径：
- docs/对话模块技术规格.md
或
- docs/对话模块/技术规格.md（如你希望建立独立目录）

请确认你偏好的保存路径与文件名。我会将本稿保存到仓库并在相关记录中添加链接。

---

## 后续计划

- 一旦确认保存路径：
  - 我将创建文档文件并提交到仓库
  - 可选：在 CHAT_IMPLEMENTATION_BACKUP.md 与 docs/对话功能实施记录/README.md 中添加“技术规格”链接
- 你若需要，我也可以补充：
  - 一页式架构图（Mermaid）
  - 快速回归测试脚本清单
  - 常见修复场景的“操作手册”附录

如果文档需加入你提到的“对话模块优化.md”系列，请告诉我准确文件名与目录，我会一并更新与联动。

