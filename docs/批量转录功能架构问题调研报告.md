# 批量转录功能架构问题调研报告

## 问题核心

用户反馈：**"在下载视频这一环节出现问题，为什么不可以直接调用之前已经实现的代码？"**

---

## 关键发现

### 1. 数据库中已有 `shareUrl` 字段

查询结果示例：
```json
{
  "id": "cmh2whgia0002wtlcy5orch8b",
  "title": "我叫陆君名字像男孩子...",
  "shareUrl": "https://www.iesdouyin.com/share/video/7523470159252589860/...",
  "externalId": "7523470159252589860"
}
```

**关键点**：
- ✅ MerchantContent 表有 `shareUrl` 字段
- ✅ TikHub API 返回的视频数据包含 `share_url`
- ✅ Mapper 会自动将 `share_url` 存入数据库（`lib/tikhub/mapper.ts:108`）
- ✅ ShareUrl 格式完整，可直接用于转录

---

### 2. 两个模块的转录代码**完全重复**

| 步骤 | 对话模块 | 批量转录模块 |
|-----|---------|------------|
| 1. 解析分享链接 | ✅ | ❌（已有externalId） |
| 2. 获取视频详情 | ✅ | ✅ **重复实现** |
| 3. 下载视频 | ✅ | ✅ **重复实现** |
| 4. 提取音频 | ✅ | ✅ **重复实现** |
| 5. GPT-4o转录 | ✅ | ✅ **重复实现** |
| 6. Claude优化 | ✅ | ✅ **重复实现** |
| 7. 更新数据库 | ❌ | ✅ |

**代码对比**：
```typescript
// app/api/douyin/extract-text/route.ts (150-188行)
const asrResponse = await fetch('https://api.302.ai/v1/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${apiKey}`,
  },
  body: JSON.stringify({
    model: 'gpt-4o-audio-preview',
    // ... 配置
  }),
})

// app/api/merchants/[id]/contents/batch-transcribe/stream/route.ts (143-181行)
const asrResponse = await fetch('https://api.302.ai/v1/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${apiKey}`,
  },
  body: JSON.stringify({
    model: 'gpt-4o-audio-preview',
    // ... 配置（完全相同）
  }),
})
```

**重复代码量**：约150行核心逻辑完全重复！

---

## 当前架构的问题

### 问题1：代码重复导致维护成本高

```
对话模块 (已验证稳定)         批量转录模块 (重新实现)
        ↓                             ↓
    转录核心逻辑 <-------------> 转录核心逻辑 (重复)
```

**后果**：
- ❌ 修复bug需要在两处修改
- ❌ 优化性能需要在两处优化
- ❌ 更新API需要在两处更新
- ❌ 容易遗漏某一处，导致不一致

### 问题2：批量转录重新实现了"下载视频"

批量转录模块在 `transcribeContent` 函数中：

```typescript
// 2. 获取视频详情
const videoDetail = await tikhubClient.getVideoDetail({
  aweme_id: content.externalId,
})

// 3. 获取视频播放地址
const videoUrl = resolvePlayableVideoUrl(awemeDetail)

// 4. 下载视频
const downloadResult = await VideoProcessor.downloadVideo(videoUrl, videoInfo, {
  headers: requestHeaders,
  maxRetries: 3,
})
```

**问题**：
- 对话模块已经实现了完全相同的逻辑
- 重新实现容易引入新bug（比如下载超时、网络错误等）
- 数据库中已有 `shareUrl`，无需重新获取视频详情

### 问题3：逻辑差异导致不一致

| 特性 | 对话模块 | 批量转录模块 |
|-----|---------|------------|
| 进度反馈 | SSE实时进度（data格式） | SSE实时进度（event格式） |
| 错误处理 | throw Error | return失败对象 |
| 下载进度 | 有onProgress回调 | 无进度回调 |
| 取消支持 | 支持req.signal | 不支持 |

这些差异导致：
- 用户体验不一致
- 难以排查问题（相同的转录任务在两个模块表现不同）

---

## 正确的架构设计

### 原则：DRY (Don't Repeat Yourself)

> "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."
> —— The Pragmatic Programmer

### 推荐架构

```
┌─────────────────────────────────────────────────┐
│          对话模块 (/douyin-tool)                │
│   用户输入：分享链接                             │
│          ↓                                      │
│   POST /api/douyin/extract-text                │
│   - 解析链接                                    │
│   - 下载视频                                    │
│   - 提取音频                                    │
│   - GPT-4o转录                                 │
│   - Claude优化                                 │
│   - 返回结果（不入库）                          │
└─────────────────────────────────────────────────┘
                    ↑
                    │ 复用
                    │
┌─────────────────────────────────────────────────┐
│       批量转录模块 (/merchants)                 │
│   数据来源：数据库 (MerchantContent)             │
│          ↓                                      │
│   1. 读取 shareUrl 字段                         │
│   2. 调用 POST /api/douyin/extract-text        │
│   3. 获取转录结果                               │
│   4. 更新数据库 (transcript, hasTranscript)    │
└─────────────────────────────────────────────────┘
```

---

## 重构方案

### 方案A：批量转录直接调用对话模块API ⭐ 推荐

#### 优点
- ✅ 代码最少，复用性最高
- ✅ 维护简单，只需维护一套转录逻辑
- ✅ 与对话模块体验一致
- ✅ 无需修改对话模块

#### 实现步骤

**1. 修改 `transcribeContent` 函数**

```typescript
async function transcribeContent(
  contentId: string,
  merchantId: string,
  apiKey: string
): Promise<{
  contentId: string
  status: 'success' | 'failed' | 'skipped'
  transcript?: string
  textLength?: number
  error?: string
}> {
  const startTime = Date.now()
  console.log(`[批量转录] 开始处理视频: ${contentId}`)

  try {
    // 1. 获取内容详情
    const content = await prisma.merchantContent.findUnique({
      where: { id: contentId },
      select: {
        id: true,
        shareUrl: true,  // ⭐ 只需要 shareUrl
        merchantId: true,
        title: true,
      },
    })

    if (!content) {
      return { contentId, status: 'failed', error: '内容不存在' }
    }

    if (content.merchantId !== merchantId) {
      return { contentId, status: 'failed', error: '内容不属于该商家' }
    }

    if (!content.shareUrl) {
      return { contentId, status: 'failed', error: '缺少分享链接' }
    }

    // 2. 调用对话模块的转录API
    console.log(`[批量转录] 调用转录API, shareUrl: ${content.shareUrl}`)
    const response = await fetch('http://localhost:3007/api/douyin/extract-text', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        shareLink: content.shareUrl,
      }),
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.error || `转录API返回错误: ${response.status}`)
    }

    if (!response.body) {
      throw new Error('转录API未返回响应体')
    }

    // 3. 解析SSE流，获取最终结果
    let finalText = ''
    const reader = response.body.getReader()
    const decoder = new TextDecoder()

    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const text = decoder.decode(value, { stream: true })
      const lines = text.split('\n')

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6))
            if (data.type === 'done') {
              finalText = data.text
              break
            }
            if (data.type === 'error') {
              throw new Error(data.message)
            }
          } catch (e) {
            console.error('[批量转录] 解析SSE数据失败:', e)
          }
        }
      }

      if (finalText) break
    }

    if (!finalText) {
      throw new Error('转录API未返回文本')
    }

    console.log(`[批量转录] 转录完成，文本长度: ${finalText.length}`)

    // 4. 更新数据库
    await prisma.merchantContent.update({
      where: { id: contentId },
      data: {
        transcript: finalText,
        hasTranscript: true,
      },
    })

    console.log(`[批量转录] 视频处理成功，总耗时: ${Date.now() - startTime}ms`)

    return {
      contentId,
      status: 'success',
      transcript: finalText,
      textLength: finalText.length,
    }
  } catch (error: any) {
    console.error(`[批量转录] 视频处理失败 (${Date.now() - startTime}ms):`, error)
    return {
      contentId,
      status: 'failed',
      error: error.message || '未知错误',
    }
  }
}
```

**2. 删除重复代码**

删除以下函数和导入：
- ❌ `optimizeTextWithLLM` 函数（已在对话模块实现）
- ❌ `resolvePlayableVideoUrl` 函数（不再需要）
- ❌ 不再需要的导入：`VideoProcessor`, `getTikHubClient`

**文件大小对比**：
- 修改前：538行
- 修改后：约250行（减少53%）

---

### 方案B：提取公共转录服务（长期方案）

创建 `lib/transcribe/service.ts`：

```typescript
/**
 * 统一的视频转录服务
 * 同时支持对话模块和批量转录模块
 */
export async function transcribeVideo(params: {
  shareLink: string
  apiKey: string
  onProgress?: (stage: string, percent: number) => void
}): Promise<{
  text: string
  originalText: string
  videoInfo: {
    title: string
    author: string
    duration: number
  }
}> {
  // 核心转录逻辑
  // 1. 解析链接
  // 2. 下载视频
  // 3. 提取音频
  // 4. GPT-4o转录
  // 5. Claude优化
  // 6. 返回结果
}
```

然后：
- 对话模块调用 `transcribeVideo`
- 批量转录模块调用 `transcribeVideo`

**优点**：
- 真正的代码复用
- 便于单元测试
- 可独立维护

**缺点**：
- 需要重构两个模块
- 工作量较大

---

## 推荐实施步骤

### 第一步：采用方案A（快速修复）

1. ✅ 修改 `transcribeContent` 函数，调用对话模块API
2. ✅ 删除重复的转录代码（150行）
3. ✅ 测试批量转录功能
4. ✅ 确认下载视频问题已解决

### 第二步：优化（可选）

1. 为对话模块API添加认证（目前无认证）
2. 添加内部API调用标识（避免速率限制）
3. 优化SSE流解析（考虑使用EventSource）

### 第三步：长期重构（可选）

1. 提取 `lib/transcribe/service.ts`
2. 两个模块都改为调用service
3. 添加单元测试

---

## 对比总结

| 维度 | 当前实现 | 方案A（推荐） | 方案B（长期） |
|-----|---------|-------------|-------------|
| 代码行数 | 538行 | ~250行 (-53%) | ~300行 |
| 维护成本 | 高（两处维护） | 低（一处维护） | 最低 |
| 下载视频问题 | ❌ 存在 | ✅ 复用稳定代码 | ✅ 复用稳定代码 |
| 实施时间 | - | 1小时 | 4-6小时 |
| 测试工作量 | - | 小 | 中 |

---

## 结论

**用户的质疑是完全正确的！**

批量转录模块确实不应该重新实现整个转录流程。正确的做法是：

1. **复用对话模块的转录API**（方案A）
2. 或**提取公共转录服务**（方案B）

**当前架构问题的本质**：
- 违反了DRY原则（Don't Repeat Yourself）
- 导致代码重复、维护困难、容易出bug

**推荐立即采用方案A**：
- 代码量减少53%
- 下载视频问题自然解决
- 维护成本大幅降低
- 与对话模块体验一致

---

## 附录：为什么会出现这个问题？

可能的原因：
1. 开发时未注意到数据库中有 `shareUrl` 字段
2. 认为批量转录需要独立实现以便优化
3. 未考虑代码复用和维护成本
4. 缺少架构review

**教训**：
- ✅ 开发新功能前先检查现有实现
- ✅ 优先复用已验证的代码
- ✅ 遵循DRY原则
- ✅ 代码review关注架构设计
