# 商家评论分析功能实施方案

## 需求确认

### 用户选择
- **问题1（存储策略）**: A - 存数据库（MerchantContentAnalysis表）
- **问题2（评论来源）**: A+B - 优先数据库，支持手动触发TikHub实时抓取
- **问题3（触发方式）**: A+C - 手动触发 + 单视频分析
- **问题4（UI展示）**: C+A - 缓存结果瞬间加载 + 首次分析SSE流式进度

### 核心需求
在商家详情页的"评论表现洞察"部分，对每个视频的100条评论进行LLM分析：
- 用户可以手动触发单个视频的评论分析
- 用户可以一键分析商家TOP5视频的评论
- 分析结果永久存储到数据库，避免重复分析浪费token
- 优先使用数据库已采集的评论，必要时才调用TikHub API实时抓取

---

## 一、数据库设计

### 1.1 新增表：MerchantContentAnalysis

```prisma
model MerchantContentAnalysis {
  id        String   @id @default(cuid())
  contentId String   @unique

  // LLM分析结果（结构化存储）
  sentimentAnalysis    String?  // JSON: 情感分析 { positive: %, neutral: %, negative: % }
  coreTopics           String?  // JSON: 核心话题 [{ topic, count, examples[] }]
  userProfile          String?  // JSON: 用户画像 { demographics, interests, behaviors }
  suggestions          String?  // JSON: 改进建议 [{ category, suggestion, priority }]

  // 完整报告
  rawMarkdown          String?  // LLM生成的完整Markdown报告

  // 元数据
  commentCount         Int      @default(0)     // 分析的评论数
  commentSource        String   @default("db")  // 'db' | 'tikhub'
  analyzedAt           DateTime @default(now())
  modelUsed            String                   // 使用的模型ID
  tokenUsed            Int      @default(0)

  // 关联关系
  content              MerchantContent @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@index([analyzedAt])
  @@map("merchant_content_analyses")
}
```

### 1.2 修改 MerchantContent 表

```prisma
model MerchantContent {
  // ... 现有字段 ...

  // 新增关联
  analysis MerchantContentAnalysis?
}
```

---

## 二、Pipeline改造

### 2.1 评论来源策略

创建新函数 `runMerchantCommentAnalysis`，基于现有的 `runDouyinCommentsPipeline` 改造：

**关键变化**：
1. **输入参数变化**：
   - 旧：`shareLink: string`
   - 新：`contentId: string, options: { forceRefresh?: boolean }`

2. **评论来源逻辑**：
```typescript
async function fetchComments(contentId: string, forceRefresh: boolean) {
  if (!forceRefresh) {
    // 优先读数据库
    const dbComments = await prisma.merchantContentComment.findMany({
      where: { contentId },
      orderBy: { diggCount: 'desc' },
      take: 100
    })

    if (dbComments.length >= 20) {
      return { source: 'db', comments: dbComments }
    }
  }

  // 回退到TikHub实时抓取
  const content = await prisma.merchantContent.findUnique({
    where: { id: contentId },
    select: { externalId: true, shareUrl: true }
  })

  const tikhubComments = await fetchFromTikHub(content.externalId)

  // 保存到数据库
  await saveToDB(contentId, tikhubComments)

  return { source: 'tikhub', comments: tikhubComments }
}
```

3. **Pipeline步骤调整**：
   - 移除 "解析链接" 步骤
   - 移除 "获取视频详情" 步骤（直接从数据库读）
   - "获取播放数据" → "加载视频信息"
   - "采集评论" → "加载评论数据"（数据库/TikHub自动切换）

### 2.2 新文件结构

```
lib/merchant/
├── comments-analysis-pipeline.ts       # 商家评论分析Pipeline
├── comments-analysis-steps.ts          # Pipeline步骤定义
└── comments-source-manager.ts          # 评论来源管理（数据库/TikHub）
```

---

## 三、API设计

### 3.1 单视频分析接口

**路由**: `POST /api/merchants/[merchantId]/contents/[contentId]/analyze`

**请求体**:
```typescript
{
  forceRefresh?: boolean  // 强制重新抓取评论（默认false）
}
```

**响应**: SSE流式输出
```
event: analysis-progress
data: {"step": "load-video", "status": "active", "percentage": 20}

event: analysis-progress
data: {"step": "fetch-comments", "status": "active", "percentage": 40, "detail": "已加载 58 条评论（来源：数据库）"}

event: analysis-partial
data: {"key": "analysis", "data": "## 1. 具体需求分析\n\n- 用户询问...", "append": true}

event: analysis-done
data: {"contentId": "xxx", "analysisId": "yyy", "markdown": "...", "commentCount": 58}
```

### 3.2 批量分析TOP5接口

**路由**: `POST /api/merchants/[merchantId]/analyze-top-videos`

**请求体**:
```typescript
{
  forceRefresh?: boolean
  metric?: 'totalEngagement' | 'diggCount' | 'commentCount'  // 默认 totalEngagement
}
```

**响应**: SSE流式输出（多个视频串行分析）
```
event: batch-start
data: {"total": 5, "videos": [{"id": "...", "title": "..."}]}

event: batch-progress
data: {"current": 1, "total": 5, "contentId": "...", "contentTitle": "..."}

event: analysis-progress  // 每个视频的分析进度
data: {"contentId": "...", "step": "...", "percentage": 40}

event: batch-complete
data: {"completed": 5, "failed": 0, "results": [...]}
```

### 3.3 查询分析结果接口

**路由**: `GET /api/merchants/[merchantId]/contents/[contentId]/analysis`

**响应**:
```typescript
{
  id: string
  contentId: string
  sentimentAnalysis: { ... }
  coreTopics: [...]
  userProfile: { ... }
  suggestions: [...]
  rawMarkdown: string
  commentCount: number
  commentSource: 'db' | 'tikhub'
  analyzedAt: string
  modelUsed: string
  tokenUsed: number
}
```

---

## 四、前端UI设计

### 4.1 组件结构

```
components/merchants/
├── content-analysis-card.tsx           # 单个视频的分析结果卡片
├── content-analysis-progress.tsx       # 分析进度条组件
├── batch-analysis-dialog.tsx           # 批量分析对话框
└── profile-ai-section.tsx              # 商家创作档案（已存在，需修改）
```

### 4.2 UI状态机

**单个视频的状态**：
```
未分析 → [点击分析] → 分析中(SSE流式) → 已完成
   ↓                                        ↓
[显示"分析评论"按钮]                    [显示分析结果卡片]
                                            ↓
                                    [显示"重新分析"按钮]
```

**批量分析状态**：
```
[点击"一键分析TOP5"] → 弹出Dialog确认 → 串行分析（显示进度）→ 完成（刷新页面）
```

### 4.3 核心Hook

```typescript
// hooks/api/use-merchant-content-analysis.ts

export function useContentAnalysis(contentId: string) {
  // 查询现有分析结果
  const { data: analysis, isLoading } = useQuery({
    queryKey: ['content-analysis', contentId],
    queryFn: () => fetchAnalysis(contentId)
  })

  return { analysis, isLoading }
}

export function useAnalyzeContent() {
  const [isAnalyzing, setIsAnalyzing] = useState(false)
  const [progress, setProgress] = useState(null)

  const analyze = useCallback(async (contentId: string, options) => {
    setIsAnalyzing(true)

    const eventSource = new EventSource(`/api/merchants/.../analyze`)

    eventSource.addEventListener('analysis-progress', (e) => {
      setProgress(JSON.parse(e.data))
    })

    eventSource.addEventListener('analysis-done', (e) => {
      const result = JSON.parse(e.data)
      queryClient.invalidateQueries(['content-analysis', contentId])
      setIsAnalyzing(false)
      eventSource.close()
    })

    // ... 错误处理
  }, [])

  return { analyze, isAnalyzing, progress }
}
```

---

## 五、实施步骤

### Phase 1: 数据库 & 后端核心 (第1-3天)

1. **数据库Schema变更**
   - [ ] 修改 `prisma/schema.prisma`，新增 `MerchantContentAnalysis` 表
   - [ ] 运行 `pnpm db:generate && pnpm db:push`
   - [ ] 验证表结构正确

2. **评论来源管理器**
   - [ ] 创建 `lib/merchant/comments-source-manager.ts`
   - [ ] 实现 `fetchCommentsForAnalysis(contentId, forceRefresh)` 函数
   - [ ] 编写单元测试

3. **商家评论分析Pipeline**
   - [ ] 创建 `lib/merchant/comments-analysis-pipeline.ts`
   - [ ] 基于现有 `comments-pipeline.ts` 改造
   - [ ] 关键改动：
     - 输入改为 `contentId`
     - 评论来源改为数据库优先
     - LLM提示词调整（适配商家场景）
   - [ ] 创建 `lib/merchant/comments-analysis-steps.ts` 定义步骤

### Phase 2: API路由 (第4-5天)

4. **单视频分析API**
   - [ ] 创建 `app/api/merchants/[merchantId]/contents/[contentId]/analyze/route.ts`
   - [ ] 实现SSE流式响应
   - [ ] 错误处理和权限验证
   - [ ] 分析结果保存到数据库

5. **批量分析API**
   - [ ] 创建 `app/api/merchants/[merchantId]/analyze-top-videos/route.ts`
   - [ ] 实现串行分析逻辑（避免并发过多）
   - [ ] 批量进度推送

6. **查询分析结果API**
   - [ ] 创建 `app/api/merchants/[merchantId]/contents/[contentId]/analysis/route.ts`
   - [ ] 返回结构化分析数据

### Phase 3: 前端UI (第6-8天)

7. **前端Hooks**
   - [ ] 创建 `hooks/api/use-merchant-content-analysis.ts`
   - [ ] 实现查询、分析、SSE监听逻辑

8. **分析结果卡片组件**
   - [ ] 创建 `components/merchants/content-analysis-card.tsx`
   - [ ] 显示情感分析、核心话题、用户画像、改进建议
   - [ ] 支持展开/折叠

9. **分析进度组件**
   - [ ] 创建 `components/merchants/content-analysis-progress.tsx`
   - [ ] 显示Pipeline步骤进度
   - [ ] 流式显示分析内容

10. **批量分析对话框**
    - [ ] 创建 `components/merchants/batch-analysis-dialog.tsx`
    - [ ] 显示TOP5视频列表
    - [ ] 串行分析进度展示

11. **集成到商家详情页**
    - [ ] 修改 `components/merchants/profile-ai-section.tsx`
    - [ ] 在"评论表现洞察"部分集成分析功能
    - [ ] 添加"一键分析TOP5"按钮

### Phase 4: 测试 & 优化 (第9-10天)

12. **完整流程测试**
    - [ ] 测试单视频分析（数据库评论）
    - [ ] 测试单视频分析（TikHub评论）
    - [ ] 测试批量分析TOP5
    - [ ] 测试重新分析（覆盖旧结果）

13. **性能优化**
    - [ ] LLM提示词优化（减少token消耗）
    - [ ] 数据库查询优化（索引验证）
    - [ ] SSE连接管理优化

14. **错误处理完善**
    - [ ] API错误统一处理
    - [ ] 前端错误提示
    - [ ] Pipeline中断恢复

---

## 六、技术风险

### 6.1 数据一致性
**问题**: 数据库评论和TikHub实时评论可能不同步

**解决方案**:
- 在分析结果中记录 `commentSource` 字段
- UI显示评论来源和采集时间
- 提供"重新抓取评论"选项

### 6.2 LLM Token消耗
**问题**: 100条评论可能消耗大量token

**解决方案**:
- 限制每次分析最多100条评论
- 评论文本截断（每条最多200字）
- 提示词优化（精简输出格式）
- 使用较便宜的模型（如 gemini-2.0-flash）

### 6.3 并发控制
**问题**: 批量分析5个视频同时请求可能导致限流

**解决方案**:
- 串行分析（一个接一个）
- 每个视频之间间隔1秒
- 使用队列机制管理批量任务

### 6.4 SSE连接稳定性
**问题**: 长时间分析可能导致连接超时

**解决方案**:
- 心跳包保持连接
- 前端自动重连机制
- 超时后从数据库读取部分结果

---

## 七、关键代码示例

### 7.1 评论来源管理器

```typescript
// lib/merchant/comments-source-manager.ts

export interface CommentSource {
  source: 'db' | 'tikhub'
  comments: CleanedComment[]
  total: number
}

export async function fetchCommentsForAnalysis(
  contentId: string,
  options: {
    forceRefresh?: boolean
    maxComments?: number
  } = {}
): Promise<CommentSource> {
  const { forceRefresh = false, maxComments = 100 } = options

  // 1. 优先数据库
  if (!forceRefresh) {
    const dbComments = await prisma.merchantContentComment.findMany({
      where: { contentId },
      orderBy: { diggCount: 'desc' },
      take: maxComments,
      select: {
        text: true,
        authorName: true,
        diggCount: true,
        replyCount: true,
        createdAt: true
      }
    })

    if (dbComments.length >= 20) {
      return {
        source: 'db',
        comments: dbComments.map(c => ({
          user: c.authorName || '匿名',
          text: cleanCommentText(c.text),
          likes: c.diggCount,
          location: ''
        })),
        total: dbComments.length
      }
    }
  }

  // 2. 回退到TikHub
  const content = await prisma.merchantContent.findUnique({
    where: { id: contentId },
    select: { externalId: true, merchantId: true }
  })

  if (!content) {
    throw new Error('Content not found')
  }

  const tikhubClient = getTikHubClient()
  const tikhubComments = await fetchCommentsFromTikHub(
    tikhubClient,
    content.externalId,
    maxComments
  )

  // 3. 保存到数据库
  await saveCommentsToDatabase(contentId, tikhubComments)

  return {
    source: 'tikhub',
    comments: tikhubComments,
    total: tikhubComments.length
  }
}
```

### 7.2 商家评论分析Pipeline

```typescript
// lib/merchant/comments-analysis-pipeline.ts

export async function runMerchantCommentAnalysis(
  contentId: string,
  emit: MerchantCommentAnalysisEmitter,
  options: {
    signal?: AbortSignal
    forceRefresh?: boolean
    maxComments?: number
  } = {}
): Promise<MerchantCommentAnalysisResult> {

  // 步骤1: 加载视频信息
  await emitProgress(emit, 'load-video', 'active')
  const content = await prisma.merchantContent.findUnique({
    where: { id: contentId },
    include: { merchant: true }
  })

  await emit({
    type: 'info',
    videoInfo: {
      videoId: content.externalId,
      title: content.title,
      author: content.merchant.name,
      diggCount: content.diggCount,
      commentCount: content.commentCount
    }
  })

  // 步骤2: 加载评论数据
  await emitProgress(emit, 'fetch-comments', 'active')
  const commentSource = await fetchCommentsForAnalysis(contentId, {
    forceRefresh: options.forceRefresh,
    maxComments: options.maxComments || 100
  })

  await emitProgress(
    emit,
    'fetch-comments',
    'completed',
    `已加载 ${commentSource.total} 条评论（来源：${commentSource.source === 'db' ? '数据库' : 'TikHub实时抓取'}）`
  )

  // 步骤3: LLM分析
  await emitProgress(emit, 'analyze-comments', 'active')
  const analysisText = await analyzeWithLLM({
    video: {
      title: content.title,
      author: content.merchant.name
    },
    statistics: {
      play_count: content.playCount,
      digg_count: content.diggCount,
      comment_count: content.commentCount,
      share_count: content.shareCount,
      collect_count: content.collectCount,
      download_count: 0
    },
    comments: commentSource.comments,
    locationStats: []
  }, apiKey, modelId, emit, options.signal)

  // 步骤4: 保存结果到数据库
  const analysis = await prisma.merchantContentAnalysis.create({
    data: {
      contentId,
      rawMarkdown: analysisText,
      commentCount: commentSource.total,
      commentSource: commentSource.source,
      analyzedAt: new Date(),
      modelUsed: modelId,
      tokenUsed: estimateTokens(analysisText)
    }
  })

  return {
    analysisId: analysis.id,
    markdown: analysisText,
    commentCount: commentSource.total,
    commentSource: commentSource.source
  }
}
```

---

## 八、成功标准

### 功能完整性
- [ ] 用户可以在商家详情页看到"评论表现洞察"区域
- [ ] 未分析的视频显示"分析评论"按钮
- [ ] 点击后显示SSE流式分析进度
- [ ] 分析完成后显示结构化洞察报告
- [ ] 已分析的视频瞬间显示缓存结果
- [ ] "一键分析TOP5"功能正常工作
- [ ] 支持"强制重新抓取评论"选项

### 性能指标
- [ ] 数据库评论分析启动延迟 < 1秒
- [ ] TikHub评论抓取 + 分析总耗时 < 60秒
- [ ] 批量分析TOP5总耗时 < 5分钟
- [ ] 缓存结果加载时间 < 500ms

### 用户体验
- [ ] SSE流式输出流畅，无卡顿
- [ ] 错误提示清晰易懂
- [ ] 分析进度百分比准确
- [ ] 可以中途取消分析

---

## 九、后续优化方向

1. **智能触发时机**
   - 新视频自动分析（Cron任务）
   - 评论数达到阈值时自动更新分析

2. **分析结果对比**
   - 历史分析记录（而不是覆盖）
   - 情感变化趋势图

3. **批量导出**
   - 导出所有视频的分析报告为PDF
   - 生成商家整体评论分析报告

4. **高级过滤**
   - 只分析高赞评论
   - 过滤营销号评论

---

**文档版本**: v1.0
**创建时间**: 2025-01-13
**负责人**: Linus
**预计完成时间**: 10个工作日
