# 音频直链重构方案

## 背景

原流程使用 FFmpeg 从视频中提取音频，但存在以下问题：
- `ffmpeg-static` 在 Vercel 环境下路径错误
- `@ffmpeg/ffmpeg` WASM 版本不支持 Node.js
- 导致 Vercel 部署后转录功能无法使用

## 解决方案

TikHub API 返回的数据中包含音频直链：
```
music.play_url.url_list[0] = "https://sf5-hl-cdn-tos.douyinstatic.com/obj/ies-music/xxx.mp3"
```

直接下载 MP3 音频，跳过 FFmpeg。

## 新流程

```
解析链接 → 获取详情 → 直接下载MP3音频 → ASR转录 → 输出
```

## 已完成的修改

### 1. lib/douyin/steps/fetch-detail.ts

**新增函数** `resolveAudioUrl()`：
```typescript
/**
 * 从TikHub返回的aweme_detail中提取音频URL
 */
function resolveAudioUrl(awemeDetail: any): string | null {
  const music = awemeDetail?.music
  if (!music) return null

  // 优先使用 play_url.url_list
  if (Array.isArray(music.play_url?.url_list) && music.play_url.url_list.length > 0) {
    return music.play_url.url_list[0]
  }

  // 备选：直接使用 play_url.uri（如果是完整URL）
  if (music.play_url?.uri && music.play_url.uri.startsWith('http')) {
    return music.play_url.uri
  }

  return null
}
```

**修改返回类型**：
```typescript
export interface FetchDetailResult {
  videoInfo: DouyinVideoInfo
  playUrl: string
  audioUrl: string | null  // 新增：音频直链
  awemeDetail: any
}
```

### 2. lib/douyin/pipeline.ts

**修改步骤3&4**：
```typescript
// ========== 步骤3&4: 获取音频 ==========
if (context.audioUrl) {
  // 直接下载音频（跳过视频下载和FFmpeg）
  await emitProgress(emit, 'download-video', 'active', '发现音频直链，直接下载音频')
  const audioResponse = await fetch(context.audioUrl)
  if (!audioResponse.ok) {
    throw new DouyinPipelineStepError(`下载音频失败: ${audioResponse.status}`, 'download-video')
  }
  const audioArrayBuffer = await audioResponse.arrayBuffer()
  context.audioBuffer = Buffer.from(audioArrayBuffer)
  await emitProgress(emit, 'download-video', 'completed', '音频下载完成')

  // 跳过FFmpeg提取步骤
  await emitProgress(emit, 'extract-audio', 'active', '使用音频直链，无需提取')
  await emitProgress(emit, 'extract-audio', 'completed', '已跳过（使用音频直链）')
} else {
  // 回退到传统流程：下载视频 → FFmpeg提取音频
  console.warn('[Pipeline] 未找到音频直链，使用传统FFmpeg流程')
  // ... 原有逻辑
}
```

---

## 待修改的文件

### 1. app/api/merchants/[id]/contents/batch-transcribe/route.ts

**位置**：第 66-108 行

**旧代码**：
```typescript
// 3. 获取视频播放地址
const videoUrl = resolvePlayableVideoUrl(awemeDetail)
if (!videoUrl) {
  return { contentId, status: 'failed', error: '无法获取视频播放地址' }
}

// 4. 下载视频
const videoInfo = await VideoProcessor.getVideoInfo(videoUrl, { headers: requestHeaders })
const downloadResult = await VideoProcessor.downloadVideo(videoUrl, videoInfo, {
  headers: requestHeaders,
  maxRetries: 3,
})
const videoBuffer = downloadResult.buffer

// 5. 提取音频
const audioBuffer = await VideoProcessor.extractAudio(videoBuffer, {
  format: 'mp3',
  sampleRate: 16000,
  channels: 1,
  bitrate: '128k',
})
```

**新代码**：
```typescript
// 3. 获取音频直链（优先）或视频播放地址（备用）
const audioUrl = resolveAudioUrl(awemeDetail)
let audioBuffer: Buffer

if (audioUrl) {
  // 直接下载音频（跳过FFmpeg）
  console.info(`[批量转录] 发现音频直链，直接下载: ${audioUrl.substring(0, 80)}...`)
  const audioResponse = await fetch(audioUrl)
  if (!audioResponse.ok) {
    return {
      contentId,
      status: 'failed',
      error: `下载音频失败: ${audioResponse.status}`,
    }
  }
  audioBuffer = Buffer.from(await audioResponse.arrayBuffer())
  console.info(`[批量转录] 音频下载完成，大小: ${(audioBuffer.length / 1024).toFixed(2)} KB`)
} else {
  // 备用：下载视频 + FFmpeg提取（仅本地环境可用）
  console.warn('[批量转录] 未找到音频直链，使用传统FFmpeg流程')
  const videoUrl = resolvePlayableVideoUrl(awemeDetail)
  if (!videoUrl) {
    return { contentId, status: 'failed', error: '无法获取视频播放地址' }
  }

  const requestHeaders: Record<string, string> = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    Referer: 'https://www.douyin.com/',
  }

  const videoInfo = await VideoProcessor.getVideoInfo(videoUrl, { headers: requestHeaders })
  const downloadResult = await VideoProcessor.downloadVideo(videoUrl, videoInfo, {
    headers: requestHeaders,
    maxRetries: 3,
  })

  audioBuffer = await VideoProcessor.extractAudio(downloadResult.buffer, {
    format: 'mp3',
    sampleRate: 16000,
    channels: 1,
    bitrate: '128k',
  })
}

// 继续转录...
```

**需要添加的辅助函数**（在文件顶部或单独位置）：
```typescript
/**
 * 从aweme_detail中提取音频URL
 */
function resolveAudioUrl(awemeDetail: any): string | null {
  const music = awemeDetail?.music
  if (!music) return null

  if (Array.isArray(music.play_url?.url_list) && music.play_url.url_list.length > 0) {
    return music.play_url.url_list[0]
  }

  if (music.play_url?.uri && music.play_url.uri.startsWith('http')) {
    return music.play_url.uri
  }

  return null
}
```

---

### 2. app/api/douyin/extract-text/route.ts

**位置**：第 83-130 行左右

**旧代码**：
```typescript
// 2. 下载视频
sendEvent('progress', {
  stage: 'downloading',
  message: '正在下载视频...',
  percent: mapStageProgress('downloading', 0),
});

const videoInfo = await VideoProcessor.getVideoInfo(videoSource.playUrl, {
  headers: requestHeaders,
});

const downloadResult = await VideoProcessor.downloadVideo(
  videoSource.playUrl,
  videoInfo,
  {
    headers: requestHeaders,
    onProgress: async (downloaded, total) => {
      const percent = Math.round((downloaded / total) * 100);
      if (percent !== lastDownloadPercent) {
        lastDownloadPercent = percent;
        sendEvent('progress', {
          stage: 'downloading',
          message: `正在下载视频... ${percent}%`,
          percent: mapStageProgress('downloading', percent),
        });
      }
    },
  }
);

// 3. 提取音频
sendEvent('progress', {
  stage: 'extracting',
  message: '正在提取音频...',
  percent: mapStageProgress('extracting', 0),
});

const audioBuffer = await VideoProcessor.extractAudio(downloadResult.buffer, {
  format: 'mp3',
  sampleRate: 16000,
  channels: 1,
  bitrate: '128k',
});
```

**新代码**：
```typescript
// 2. 获取音频
let audioBuffer: Buffer

// 检查是否有音频直链
const audioUrl = videoSource.audioUrl // 需要在 videoSource 中添加此字段

if (audioUrl) {
  // 直接下载音频（跳过视频下载和FFmpeg）
  sendEvent('progress', {
    stage: 'downloading',
    message: '发现音频直链，正在下载音频...',
    percent: mapStageProgress('downloading', 50),
  });

  const audioResponse = await fetch(audioUrl);
  if (!audioResponse.ok) {
    throw new Error(`下载音频失败: ${audioResponse.status}`);
  }
  audioBuffer = Buffer.from(await audioResponse.arrayBuffer());

  sendEvent('progress', {
    stage: 'extracting',
    message: '音频直链下载完成，跳过提取步骤',
    percent: mapStageProgress('extracting', 100),
  });
} else {
  // 备用：下载视频 + FFmpeg提取
  sendEvent('progress', {
    stage: 'downloading',
    message: '正在下载视频...',
    percent: mapStageProgress('downloading', 0),
  });

  const videoInfo = await VideoProcessor.getVideoInfo(videoSource.playUrl, {
    headers: requestHeaders,
  });

  let lastDownloadPercent = -1;
  const downloadResult = await VideoProcessor.downloadVideo(
    videoSource.playUrl,
    videoInfo,
    {
      headers: requestHeaders,
      onProgress: async (downloaded, total) => {
        const percent = Math.round((downloaded / total) * 100);
        if (percent !== lastDownloadPercent) {
          lastDownloadPercent = percent;
          sendEvent('progress', {
            stage: 'downloading',
            message: `正在下载视频... ${percent}%`,
            percent: mapStageProgress('downloading', percent),
          });
        }
      },
    }
  );

  sendEvent('progress', {
    stage: 'extracting',
    message: '正在提取音频...',
    percent: mapStageProgress('extracting', 0),
  });

  audioBuffer = await VideoProcessor.extractAudio(downloadResult.buffer, {
    format: 'mp3',
    sampleRate: 16000,
    channels: 1,
    bitrate: '128k',
  });
}

// 继续转录...
```

**还需要修改** `lib/douyin/video-source.ts`（如果存在），在 `createVideoSourceFromShareLink` 返回值中添加 `audioUrl` 字段。

---

## 测试脚本

已创建测试脚本：
- `scripts/test-audio-url.ts` - 测试 TikHub 是否返回音频 URL
- `scripts/test-audio-direct-download.ts` - 测试直接下载音频
- `scripts/test-full-audio-transcribe.ts` - 完整测试：音频直链 → ASR转录

运行测试：
```bash
TIKHUB_API_KEY="xxx" LLM_API_KEY="xxx" npx tsx scripts/test-full-audio-transcribe.ts
```

---

## 注意事项

1. **音频直链可能为空**：某些视频可能没有 `music.play_url`，需要保留 FFmpeg 备用流程
2. **音频格式**：TikHub 返回的是 MP3 格式，可直接用于 ASR
3. **音频大小**：通常在 500KB - 2MB 之间，比视频小很多
4. **Vercel 兼容**：新流程不依赖 FFmpeg，可在 Vercel 正常运行

---

## 可删除的文件（可选）

以下文件在新流程中不再必需，但建议保留作为备用：
- `lib/video/ffmpeg-wasm.ts`
- `lib/video/video-processor.ts`（部分功能仍在使用）
- `lib/douyin/steps/extract-audio.ts`

以下测试脚本可以删除：
- `scripts/test-audio-url.ts`
- `scripts/test-audio-direct-download.ts`
- `scripts/test-full-audio-transcribe.ts`
