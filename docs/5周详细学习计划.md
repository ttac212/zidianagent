# æ™ºç‚¹AIå¹³å° - 5å‘¨è¯¦ç»†å­¦ä¹ è®¡åˆ’ï¼ˆ210å°æ—¶ï¼‰

---

## ğŸ“… å­¦ä¹ è®¡åˆ’æ€»è§ˆ

| å‘¨æ¬¡ | ä¸»é¢˜ | å­¦ä¹ æ—¶é•¿ | æ ¸å¿ƒç›®æ ‡ |
|------|------|----------|----------|
| Week 1 | å‰ç«¯åŸºç¡€è¡¥å¼º | 42å°æ—¶ | æŒæ¡TypeScript + React + Next.jsåŸºç¡€ |
| Week 2 | é¡¹ç›®æ ¸å¿ƒæµç¨‹ | 42å°æ—¶ | ç†è§£èŠå¤©ç³»ç»Ÿå®Œæ•´é“¾è·¯ |
| Week 3 | å‰ç«¯æ¶æ„æ·±å…¥ | 42å°æ—¶ | æŒæ¡çŠ¶æ€ç®¡ç†å’Œç¼“å­˜ç­–ç•¥ |
| Week 4 | é«˜çº§ä¸»é¢˜ | 42å°æ—¶ | SSEæµå¼å¤„ç†å’Œå¹¶å‘æ§åˆ¶ |
| Week 5 | å®æˆ˜é¡¹ç›® | 42å°æ—¶ | ç‹¬ç«‹å¼€å‘æ–°åŠŸèƒ½ |

---

# Week 1ï¼šå‰ç«¯åŸºç¡€è¡¥å¼ºï¼ˆ42å°æ—¶ï¼‰

## Day 1ï¼šTypeScriptç±»å‹ç³»ç»Ÿï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šåŸºç¡€ç±»å‹å’Œæ¥å£

**å­¦ä¹ å†…å®¹ï¼š**

1. åŸºç¡€ç±»å‹ï¼ˆstring, number, boolean, array, objectï¼‰
2. æ¥å£ï¼ˆinterfaceï¼‰å’Œç±»å‹åˆ«åï¼ˆtypeï¼‰
3. è”åˆç±»å‹å’Œäº¤å‰ç±»å‹
4. å¯é€‰å±æ€§å’Œåªè¯»å±æ€§

**æ¨èèµ„æºï¼š**
- TypeScriptå®˜æ–¹æ–‡æ¡£ï¼šhttps://www.typescriptlang.org/docs/handbook/2/everyday-types.html
- è§†é¢‘æ•™ç¨‹ï¼ˆ1å°æ—¶ï¼‰ï¼šTypeScriptå…¥é—¨ by Fireship

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/day1-types.ts

// ä»»åŠ¡1ï¼šå®šä¹‰ç”¨æˆ·ç±»å‹
interface User {
  id: string
  email: string
  displayName?: string
  role: 'USER' | 'ADMIN' | 'GUEST'
  createdAt: Date
}

// ä»»åŠ¡2ï¼šå®šä¹‰æ¶ˆæ¯ç±»å‹
interface Message {
  id: string
  content: string
  role: 'user' | 'assistant'
  createdAt: Date
}

// ä»»åŠ¡3ï¼šå®šä¹‰å¯¹è¯ç±»å‹ï¼ˆåŒ…å«æ¶ˆæ¯æ•°ç»„ï¼‰
interface Conversation {
  id: string
  title: string
  userId: string
  messages: Message[]
  createdAt: Date
  updatedAt: Date
}

// ä»»åŠ¡4ï¼šç¼–å†™ç±»å‹å®ˆå«å‡½æ•°
function isAdminUser(user: User): user is User & { role: 'ADMIN' } {
  return user.role === 'ADMIN'
}

// æµ‹è¯•
const testUser: User = {
  id: '1',
  email: 'test@test.com',
  role: 'ADMIN',
  createdAt: new Date()
}

if (isAdminUser(testUser)) {
  console.log('This is admin')
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šæ³›å‹å’Œé«˜çº§ç±»å‹

**å­¦ä¹ å†…å®¹ï¼š**
1. æ³›å‹åŸºç¡€ï¼ˆGeneric Typesï¼‰
2. æ³›å‹çº¦æŸï¼ˆGeneric Constraintsï¼‰
3. å®ç”¨å·¥å…·ç±»å‹ï¼ˆPartial, Required, Pick, Omitï¼‰
4. é¡¹ç›®ä¸­çš„ç±»å‹å®šä¹‰

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/day1-generics.ts

// ä»»åŠ¡1ï¼šç¼–å†™æ³›å‹å‡½æ•°
function createArray<T>(length: number, value: T): T[] {
  return Array(length).fill(value)
}

const numbers = createArray<number>(3, 0) // [0, 0, 0]
const strings = createArray<string>(2, 'hello') // ['hello', 'hello']

// ä»»åŠ¡2ï¼šç¼–å†™æ³›å‹æ¥å£
interface ApiResponse<T> {
  data: T
  error: string | null
  success: boolean
}

// ä½¿ç”¨ç¤ºä¾‹
const userResponse: ApiResponse<User> = {
  data: { id: '1', email: 'test@test.com', role: 'USER', createdAt: new Date() },
  error: null,
  success: true
}

// ä»»åŠ¡3ï¼šä½¿ç”¨å·¥å…·ç±»å‹
type PartialUser = Partial<User> // æ‰€æœ‰å±æ€§å¯é€‰
type UserWithoutDates = Omit<User, 'createdAt'> // æ’é™¤æŸäº›å±æ€§
type UserEmailAndRole = Pick<User, 'email' | 'role'> // åªä¿ç•™æŸäº›å±æ€§

// ä»»åŠ¡4ï¼šé˜…è¯»é¡¹ç›®ç±»å‹å®šä¹‰
// æ‰“å¼€å¹¶ç†è§£ï¼štypes/chat.ts
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡Šinterfaceå’Œtypeçš„åŒºåˆ«
- [ ] èƒ½ç¼–å†™ç®€å•çš„æ³›å‹å‡½æ•°
- [ ] èƒ½ä½¿ç”¨Partialã€Omitç­‰å·¥å…·ç±»å‹
- [ ] èƒ½è¯»æ‡‚ `types/chat.ts` ä¸­çš„ç±»å‹å®šä¹‰

---

## Day 2ï¼šTypeScriptåœ¨Reactä¸­çš„åº”ç”¨ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šReactç»„ä»¶ç±»å‹

**å­¦ä¹ å†…å®¹ï¼š**
1. å‡½æ•°ç»„ä»¶ç±»å‹å®šä¹‰
2. Propsç±»å‹å®šä¹‰
3. äº‹ä»¶å¤„ç†å™¨ç±»å‹
4. Hooksç±»å‹ï¼ˆuseState, useEffectï¼‰

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/components/Button.tsx

import React from 'react'

// ä»»åŠ¡1ï¼šå®šä¹‰Propsç±»å‹
interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary' | 'danger'
  disabled?: boolean
  className?: string
}

// ä»»åŠ¡2ï¼šç¼–å†™ç±»å‹åŒ–çš„å‡½æ•°ç»„ä»¶
export function Button({
  children,
  onClick,
  variant = 'primary',
  disabled = false,
  className = ''
}: ButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant} ${className}`}
    >
      {children}
    </button>
  )
}

// ä»»åŠ¡3ï¼šç¼–å†™å¸¦çŠ¶æ€çš„ç»„ä»¶
interface CounterProps {
  initialCount?: number
}

export function Counter({ initialCount = 0 }: CounterProps) {
  const [count, setCount] = React.useState<number>(initialCount)

  const handleIncrement = () => setCount(prev => prev + 1)
  const handleDecrement = () => setCount(prev => prev - 1)

  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={handleIncrement}>+</Button>
      <Button onClick={handleDecrement}>-</Button>
    </div>
  )
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šé¡¹ç›®ç±»å‹å®è·µ

**å­¦ä¹ å†…å®¹ï¼š**
1. é˜…è¯» `types/chat.ts`
2. ç†è§£é¡¹ç›®ä¸­çš„æ ¸å¿ƒç±»å‹
3. å­¦ä¹ ç±»å‹æ‰©å±•å’Œæ¨¡å—å£°æ˜

**å®è·µä»»åŠ¡ï¼š**
```bash
# æ‰“å¼€é¡¹ç›®æ–‡ä»¶
code types/chat.ts
```

**è¯¦ç»†é˜…è¯»ä»¥ä¸‹ç±»å‹ï¼Œå¹¶æ·»åŠ æ³¨é‡Šï¼š**
```typescript
// types/chat.ts å…³é”®ç±»å‹è§£è¯»

// 1. ChatMessage - èŠå¤©æ¶ˆæ¯
export interface ChatMessage {
  id: string                    // å”¯ä¸€æ ‡è¯†ç¬¦
  role: 'user' | 'assistant'   // æ¶ˆæ¯è§’è‰²
  content: string               // æ¶ˆæ¯å†…å®¹
  status: 'pending' | 'streaming' | 'completed' | 'error'  // æ¶ˆæ¯çŠ¶æ€
  reasoning?: string            // AIæ¨ç†è¿‡ç¨‹ï¼ˆå¯é€‰ï¼‰
  createdAt: Date              // åˆ›å»ºæ—¶é—´
  metadata?: Record<string, any> // å…ƒæ•°æ®ï¼ˆå¯é€‰ï¼‰
}

// 2. ChatState - èŠå¤©çŠ¶æ€ï¼ˆReducerä½¿ç”¨ï¼‰
export interface ChatState {
  messages: ChatMessage[]       // æ¶ˆæ¯åˆ—è¡¨
  isLoading: boolean           // æ˜¯å¦æ­£åœ¨åŠ è½½
  error: string | null         // é”™è¯¯ä¿¡æ¯
  // ... å…¶ä»–å­—æ®µ
}

// 3. ChatAction - èŠå¤©åŠ¨ä½œï¼ˆReducerä½¿ç”¨ï¼‰
export type ChatAction =
  | { type: 'SEND_USER_MESSAGE'; payload: { message: ChatMessage } }
  | { type: 'UPDATE_MESSAGE_STREAM'; payload: { id: string; content: string } }
  | { type: 'REMOVE_MESSAGE'; payload: { id: string } }
  // ... å…¶ä»–åŠ¨ä½œ
```

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] ä¸ºæ¯ä¸ªç±»å‹æ·»åŠ ä¸­æ–‡æ³¨é‡Š
- [ ] ç†è§£ChatMessageçš„statuså­—æ®µçš„4ç§çŠ¶æ€
- [ ] ç†è§£ChatActionçš„è”åˆç±»å‹è®¾è®¡
- [ ] ç”»å‡ºChatMessageçš„çŠ¶æ€è½¬æ¢å›¾

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠChatMessageä¸­æ¯ä¸ªå­—æ®µçš„ä½œç”¨
- [ ] èƒ½è¯´å‡ºæ¶ˆæ¯çš„4ç§çŠ¶æ€åŠå…¶è½¬æ¢å…³ç³»
- [ ] èƒ½ç†è§£Reducerä¸­Actionçš„ç±»å‹å®‰å…¨è®¾è®¡

---

## Day 3ï¼šReact HooksåŸºç¡€ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šuseStateå’ŒuseEffect

**å­¦ä¹ å†…å®¹ï¼š**
1. useStateåŸºç¡€ç”¨æ³•
2. useStateçš„å‡½æ•°å¼æ›´æ–°
3. useEffectä¾èµ–æ•°ç»„
4. useEffectæ¸…ç†å‡½æ•°

**æ¨èèµ„æºï¼š**
- Reactå®˜æ–¹æ–‡æ¡£ï¼šhttps://react.dev/learn/state-a-components-memory
- è§†é¢‘æ•™ç¨‹ï¼šReact Hooksæ·±å…¥ by Web Dev Simplified

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/components/TodoList.tsx

import React, { useState, useEffect } from 'react'

interface Todo {
  id: string
  text: string
  completed: boolean
}

export function TodoList() {
  // ä»»åŠ¡1ï¼šä½¿ç”¨useStateç®¡ç†çŠ¶æ€
  const [todos, setTodos] = useState<Todo[]>([])
  const [inputValue, setInputValue] = useState('')

  // ä»»åŠ¡2ï¼šä½¿ç”¨useEffectä»localStorageåŠ è½½æ•°æ®
  useEffect(() => {
    const saved = localStorage.getItem('todos')
    if (saved) {
      setTodos(JSON.parse(saved))
    }
  }, []) // ç©ºä¾èµ–æ•°ç»„ï¼šåªåœ¨ç»„ä»¶æŒ‚è½½æ—¶æ‰§è¡Œ

  // ä»»åŠ¡3ï¼šä½¿ç”¨useEffectä¿å­˜æ•°æ®åˆ°localStorage
  useEffect(() => {
    if (todos.length > 0) {
      localStorage.setItem('todos', JSON.stringify(todos))
    }
  }, [todos]) // ä¾èµ–todosï¼štodoså˜åŒ–æ—¶æ‰§è¡Œ

  // æ·»åŠ å¾…åŠäº‹é¡¹
  const addTodo = () => {
    if (inputValue.trim()) {
      setTodos(prev => [
        ...prev,
        { id: Date.now().toString(), text: inputValue, completed: false }
      ])
      setInputValue('')
    }
  }

  // åˆ‡æ¢å®ŒæˆçŠ¶æ€
  const toggleTodo = (id: string) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    )
  }

  // åˆ é™¤å¾…åŠäº‹é¡¹
  const deleteTodo = (id: string) => {
    setTodos(prev => prev.filter(todo => todo.id !== id))
  }

  return (
    <div>
      <input
        value={inputValue}
        onChange={e => setInputValue(e.target.value)}
        onKeyPress={e => e.key === 'Enter' && addTodo()}
      />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šuseRefå’ŒuseCallback

**å­¦ä¹ å†…å®¹ï¼š**
1. useRefè®¿é—®DOMå…ƒç´ 
2. useRefå­˜å‚¨å¯å˜å€¼
3. useCallbackä¼˜åŒ–æ€§èƒ½
4. useMemo vs useCallback

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/components/ChatInput.tsx

import React, { useState, useRef, useCallback, useEffect } from 'react'

interface ChatInputProps {
  onSend: (message: string) => void
  disabled?: boolean
}

export function ChatInput({ onSend, disabled = false }: ChatInputProps) {
  const [input, setInput] = useState('')
  const textareaRef = useRef<HTMLTextAreaElement>(null)

  // ä»»åŠ¡1ï¼šä½¿ç”¨useRefèšç„¦è¾“å…¥æ¡†
  useEffect(() => {
    if (textareaRef.current && !disabled) {
      textareaRef.current.focus()
    }
  }, [disabled])

  // ä»»åŠ¡2ï¼šä½¿ç”¨useCallbackä¼˜åŒ–å‡½æ•°
  const handleSend = useCallback(() => {
    if (input.trim() && !disabled) {
      onSend(input)
      setInput('')
      // èšç„¦è¾“å…¥æ¡†
      textareaRef.current?.focus()
    }
  }, [input, disabled, onSend])

  // ä»»åŠ¡3ï¼šå¤„ç†å¿«æ·é”®ï¼ˆCtrl+Enterå‘é€ï¼‰
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault()
      handleSend()
    }
  }, [handleSend])

  return (
    <div>
      <textarea
        ref={textareaRef}
        value={input}
        onChange={e => setInput(e.target.value)}
        onKeyDown={handleKeyDown}
        disabled={disabled}
        placeholder="è¾“å…¥æ¶ˆæ¯... (Ctrl+Enterå‘é€)"
        rows={3}
      />
      <button onClick={handleSend} disabled={disabled || !input.trim()}>
        å‘é€
      </button>
    </div>
  )
}
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠuseStateçš„å‡½æ•°å¼æ›´æ–°çš„å¥½å¤„
- [ ] èƒ½è§£é‡ŠuseEffectä¾èµ–æ•°ç»„çš„ä½œç”¨
- [ ] èƒ½ä½¿ç”¨useRefè®¿é—®DOMå’Œå­˜å‚¨å¯å˜å€¼
- [ ] èƒ½è§£é‡ŠuseCallbackçš„ä½¿ç”¨åœºæ™¯

---

## Day 4ï¼šReact useReduceræ·±å…¥ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šReduceræ¨¡å¼åŸºç¡€

**å­¦ä¹ å†…å®¹ï¼š**
1. Reduceræ¦‚å¿µï¼ˆçº¯å‡½æ•°ã€ä¸å¯å˜æ€§ï¼‰
2. Actionå’ŒStateè®¾è®¡
3. useReducer vs useState
4. ä½•æ—¶ä½¿ç”¨Reducer

**æ¨èèµ„æºï¼š**
- Reactæ–‡æ¡£ï¼šhttps://react.dev/learn/extracting-state-logic-into-a-reducer
- Reduxæ–‡æ¡£ï¼ˆç†è§£æ¦‚å¿µï¼‰ï¼šhttps://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/reducers/todoReducer.ts

// ä»»åŠ¡1ï¼šå®šä¹‰Stateç±»å‹
interface TodoState {
  todos: Array<{ id: string; text: string; completed: boolean }>
  filter: 'all' | 'active' | 'completed'
}

// ä»»åŠ¡2ï¼šå®šä¹‰Actionç±»å‹ï¼ˆè”åˆç±»å‹ï¼‰
type TodoAction =
  | { type: 'ADD_TODO'; payload: { text: string } }
  | { type: 'TOGGLE_TODO'; payload: { id: string } }
  | { type: 'DELETE_TODO'; payload: { id: string } }
  | { type: 'SET_FILTER'; payload: { filter: TodoState['filter'] } }
  | { type: 'CLEAR_COMPLETED' }

// ä»»åŠ¡3ï¼šç¼–å†™Reducerå‡½æ•°ï¼ˆçº¯å‡½æ•°ï¼‰
export function todoReducer(state: TodoState, action: TodoAction): TodoState {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now().toString(),
            text: action.payload.text,
            completed: false
          }
        ]
      }

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      }

    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id)
      }

    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload.filter
      }

    case 'CLEAR_COMPLETED':
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed)
      }

    default:
      return state
  }
}

// ä»»åŠ¡4ï¼šåˆå§‹çŠ¶æ€
export const initialTodoState: TodoState = {
  todos: [],
  filter: 'all'
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šåœ¨ç»„ä»¶ä¸­ä½¿ç”¨Reducer

**å®è·µä»»åŠ¡ï¼š**
```typescript
// åˆ›å»ºæ–‡ä»¶ï¼štest-learning/components/TodoApp.tsx

import React, { useReducer, useMemo } from 'react'
import { todoReducer, initialTodoState } from '../reducers/todoReducer'

export function TodoApp() {
  // ä»»åŠ¡1ï¼šä½¿ç”¨useReducer
  const [state, dispatch] = useReducer(todoReducer, initialTodoState)
  const [input, setInput] = React.useState('')

  // ä»»åŠ¡2ï¼šæ ¹æ®filterç­›é€‰todosï¼ˆä½¿ç”¨useMemoä¼˜åŒ–ï¼‰
  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed)
      case 'completed':
        return state.todos.filter(todo => todo.completed)
      default:
        return state.todos
    }
  }, [state.todos, state.filter])

  // ä»»åŠ¡3ï¼šdispatchä¸åŒç±»å‹çš„action
  const handleAdd = () => {
    if (input.trim()) {
      dispatch({ type: 'ADD_TODO', payload: { text: input } })
      setInput('')
    }
  }

  const handleToggle = (id: string) => {
    dispatch({ type: 'TOGGLE_TODO', payload: { id } })
  }

  const handleDelete = (id: string) => {
    dispatch({ type: 'DELETE_TODO', payload: { id } })
  }

  const handleFilterChange = (filter: 'all' | 'active' | 'completed') => {
    dispatch({ type: 'SET_FILTER', payload: { filter } })
  }

  const handleClearCompleted = () => {
    dispatch({ type: 'CLEAR_COMPLETED' })
  }

  return (
    <div>
      <h1>Todo App with Reducer</h1>

      {/* è¾“å…¥åŒºåŸŸ */}
      <div>
        <input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyPress={e => e.key === 'Enter' && handleAdd()}
          placeholder="What needs to be done?"
        />
        <button onClick={handleAdd}>Add</button>
      </div>

      {/* è¿‡æ»¤å™¨ */}
      <div>
        <button onClick={() => handleFilterChange('all')}>All</button>
        <button onClick={() => handleFilterChange('active')}>Active</button>
        <button onClick={() => handleFilterChange('completed')}>Completed</button>
        <button onClick={handleClearCompleted}>Clear Completed</button>
      </div>

      {/* Todoåˆ—è¡¨ */}
      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggle(todo.id)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => handleDelete(todo.id)}>Ã—</button>
          </li>
        ))}
      </ul>

      {/* ç»Ÿè®¡ */}
      <div>
        {state.todos.filter(t => !t.completed).length} items left
      </div>
    </div>
  )
}
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠReducerçš„ä¸‰ä¸ªåŸåˆ™ï¼ˆçº¯å‡½æ•°ã€ä¸å¯å˜ã€ç¡®å®šæ€§ï¼‰
- [ ] èƒ½è§£é‡Šä¸ºä»€ä¹ˆè¦ç”¨è”åˆç±»å‹å®šä¹‰Action
- [ ] èƒ½è§£é‡Šä½•æ—¶ç”¨useReducerè€Œä¸æ˜¯useState
- [ ] èƒ½ç‹¬ç«‹ç¼–å†™ç®€å•çš„Reducer

---

## Day 5ï¼šNext.js App Routerï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šè·¯ç”±ç³»ç»Ÿ

**å­¦ä¹ å†…å®¹ï¼š**
1. App Router vs Pages Router
2. æ–‡ä»¶ç³»ç»Ÿè·¯ç”±
3. åŠ¨æ€è·¯ç”± `[id]`
4. è·¯ç”±ç»„ `(group)`
5. å¸ƒå±€ï¼ˆLayoutï¼‰å’Œæ¨¡æ¿ï¼ˆTemplateï¼‰

**æ¨èèµ„æºï¼š**
- Next.jså®˜æ–¹æ–‡æ¡£ï¼šhttps://nextjs.org/docs/app/building-your-application/routing

**å®è·µä»»åŠ¡ï¼š**
```bash
# åˆ›å»ºNext.jsæµ‹è¯•é¡¹ç›®
npx create-next-app@latest test-nextjs --typescript --app --no-src-dir

cd test-nextjs
```

**ä»»åŠ¡1ï¼šåˆ›å»ºåŸºç¡€è·¯ç”±ç»“æ„**
```
app/
â”œâ”€â”€ page.tsx                    # é¦–é¡µ /
â”œâ”€â”€ about/
â”‚   â””â”€â”€ page.tsx               # å…³äºé¡µ /about
â”œâ”€â”€ blog/
â”‚   â”œâ”€â”€ page.tsx               # åšå®¢åˆ—è¡¨ /blog
â”‚   â””â”€â”€ [slug]/
â”‚       â””â”€â”€ page.tsx           # åšå®¢è¯¦æƒ… /blog/[slug]
â””â”€â”€ dashboard/
    â”œâ”€â”€ layout.tsx             # Dashboardå¸ƒå±€
    â”œâ”€â”€ page.tsx               # Dashboardé¦–é¡µ /dashboard
    â””â”€â”€ settings/
        â””â”€â”€ page.tsx           # è®¾ç½®é¡µ /dashboard/settings
```

**ä»»åŠ¡2ï¼šå®ç°åŠ¨æ€è·¯ç”±**
```typescript
// app/blog/[slug]/page.tsx

interface BlogPostProps {
  params: {
    slug: string
  }
}

export default function BlogPost({ params }: BlogPostProps) {
  return (
    <div>
      <h1>Blog Post: {params.slug}</h1>
      <p>This is the blog post with slug: {params.slug}</p>
    </div>
  )
}
```

**ä»»åŠ¡3ï¼šå®ç°å¸ƒå±€**
```typescript
// app/dashboard/layout.tsx

export default function DashboardLayout({
  children
}: {
  children: React.ReactNode
}) {
  return (
    <div>
      <nav>
        <a href="/dashboard">Dashboard</a>
        <a href="/dashboard/settings">Settings</a>
      </nav>
      <main>{children}</main>
    </div>
  )
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šæœåŠ¡ç«¯ç»„ä»¶å’Œå®¢æˆ·ç«¯ç»„ä»¶

**å­¦ä¹ å†…å®¹ï¼š**
1. Server Components vs Client Components
2. 'use client' æŒ‡ä»¤
3. ä½•æ—¶ä½¿ç”¨å“ªç§ç»„ä»¶
4. æ•°æ®è·å–æ¨¡å¼

**å®è·µä»»åŠ¡ï¼š**
```typescript
// app/posts/page.tsx (æœåŠ¡ç«¯ç»„ä»¶)

interface Post {
  id: number
  title: string
  body: string
}

// æœåŠ¡ç«¯ç»„ä»¶å¯ä»¥ç›´æ¥async
export default async function PostsPage() {
  // ç›´æ¥åœ¨ç»„ä»¶ä¸­è·å–æ•°æ®
  const res = await fetch('https://jsonplaceholder.typicode.com/posts', {
    cache: 'no-store' // ç¦ç”¨ç¼“å­˜
  })
  const posts: Post[] = await res.json()

  return (
    <div>
      <h1>Posts (Server Component)</h1>
      <ul>
        {posts.slice(0, 10).map(post => (
          <li key={post.id}>
            <h3>{post.title}</h3>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

```typescript
// app/counter/page.tsx

'use client' // å®¢æˆ·ç«¯ç»„ä»¶æ ‡è®°

import { useState } from 'react'

// å®¢æˆ·ç«¯ç»„ä»¶å¯ä»¥ä½¿ç”¨Hookså’Œäº‹ä»¶å¤„ç†
export default function CounterPage() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h1>Counter (Client Component)</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  )
}
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½åˆ›å»ºåŸºç¡€è·¯ç”±å’ŒåŠ¨æ€è·¯ç”±
- [ ] èƒ½ç†è§£Layoutçš„ä½œç”¨å’Œä½¿ç”¨åœºæ™¯
- [ ] èƒ½åŒºåˆ†Server Componentå’ŒClient Component
- [ ] èƒ½è§£é‡Šä½•æ—¶ä½¿ç”¨'use client'

---

## Day 6ï¼šNext.js API Routesï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šAPIè·¯ç”±åŸºç¡€

**å­¦ä¹ å†…å®¹ï¼š**
1. APIè·¯ç”±æ–‡ä»¶ç»“æ„
2. HTTPæ–¹æ³•å¤„ç†ï¼ˆGETã€POSTã€PATCHã€DELETEï¼‰
3. Requestå’ŒResponseå¯¹è±¡
4. åŠ¨æ€APIè·¯ç”±

**å®è·µä»»åŠ¡ï¼š**
```typescript
// app/api/hello/route.ts

import { NextRequest, NextResponse } from 'next/server'

// GET /api/hello
export async function GET(request: NextRequest) {
  return NextResponse.json({
    message: 'Hello from API',
    timestamp: new Date().toISOString()
  })
}

// POST /api/hello
export async function POST(request: NextRequest) {
  const body = await request.json()

  return NextResponse.json({
    message: 'Data received',
    data: body
  })
}
```

**ä»»åŠ¡1ï¼šåˆ›å»ºTodo API**
```typescript
// app/api/todos/route.ts

import { NextRequest, NextResponse } from 'next/server'

// æ¨¡æ‹Ÿæ•°æ®åº“
let todos: Array<{ id: string; text: string; completed: boolean }> = []

// GET /api/todos - è·å–æ‰€æœ‰todos
export async function GET() {
  return NextResponse.json({ todos })
}

// POST /api/todos - åˆ›å»ºæ–°todo
export async function POST(request: NextRequest) {
  const { text } = await request.json()

  if (!text) {
    return NextResponse.json(
      { error: 'Text is required' },
      { status: 400 }
    )
  }

  const newTodo = {
    id: Date.now().toString(),
    text,
    completed: false
  }

  todos.push(newTodo)

  return NextResponse.json(
    { todo: newTodo },
    { status: 201 }
  )
}
```

**ä»»åŠ¡2ï¼šåˆ›å»ºåŠ¨æ€APIè·¯ç”±**
```typescript
// app/api/todos/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server'

// æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å¯¼å…¥todosæ•°ç»„ï¼ˆå®é™…é¡¹ç›®ä¸­ä¼šç”¨æ•°æ®åº“ï¼‰

// GET /api/todos/[id] - è·å–å•ä¸ªtodo
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const todo = todos.find(t => t.id === params.id)

  if (!todo) {
    return NextResponse.json(
      { error: 'Todo not found' },
      { status: 404 }
    )
  }

  return NextResponse.json({ todo })
}

// PATCH /api/todos/[id] - æ›´æ–°todo
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const { completed } = await request.json()
  const index = todos.findIndex(t => t.id === params.id)

  if (index === -1) {
    return NextResponse.json(
      { error: 'Todo not found' },
      { status: 404 }
    )
  }

  todos[index] = { ...todos[index], completed }

  return NextResponse.json({ todo: todos[index] })
}

// DELETE /api/todos/[id] - åˆ é™¤todo
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const index = todos.findIndex(t => t.id === params.id)

  if (index === -1) {
    return NextResponse.json(
      { error: 'Todo not found' },
      { status: 404 }
    )
  }

  todos.splice(index, 1)

  return NextResponse.json({ success: true })
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šé›†æˆå‰åç«¯

**å®è·µä»»åŠ¡ï¼šåˆ›å»ºå®Œæ•´çš„Todoåº”ç”¨**

```typescript
// app/todos-fullstack/page.tsx

'use client'

import { useState, useEffect } from 'react'

interface Todo {
  id: string
  text: string
  completed: boolean
}

export default function TodosFullstackPage() {
  const [todos, setTodos] = useState<Todo[]>([])
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)

  // åŠ è½½todos
  useEffect(() => {
    fetchTodos()
  }, [])

  const fetchTodos = async () => {
    const res = await fetch('/api/todos')
    const data = await res.json()
    setTodos(data.todos)
  }

  // æ·»åŠ todo
  const handleAdd = async () => {
    if (!input.trim()) return

    setLoading(true)
    try {
      const res = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: input })
      })
      const data = await res.json()
      setTodos([...todos, data.todo])
      setInput('')
    } catch (error) {
      console.error('Failed to add todo:', error)
    } finally {
      setLoading(false)
    }
  }

  // åˆ‡æ¢å®ŒæˆçŠ¶æ€
  const handleToggle = async (id: string, completed: boolean) => {
    try {
      await fetch(`/api/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !completed })
      })
      setTodos(todos.map(t =>
        t.id === id ? { ...t, completed: !completed } : t
      ))
    } catch (error) {
      console.error('Failed to toggle todo:', error)
    }
  }

  // åˆ é™¤todo
  const handleDelete = async (id: string) => {
    try {
      await fetch(`/api/todos/${id}`, { method: 'DELETE' })
      setTodos(todos.filter(t => t.id !== id))
    } catch (error) {
      console.error('Failed to delete todo:', error)
    }
  }

  return (
    <div>
      <h1>Fullstack Todo App</h1>
      <div>
        <input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyPress={e => e.key === 'Enter' && handleAdd()}
        />
        <button onClick={handleAdd} disabled={loading}>
          {loading ? 'Adding...' : 'Add'}
        </button>
      </div>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggle(todo.id, todo.completed)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => handleDelete(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½åˆ›å»ºåŸºç¡€APIè·¯ç”±ï¼ˆGETã€POSTï¼‰
- [ ] èƒ½åˆ›å»ºåŠ¨æ€APIè·¯ç”±
- [ ] èƒ½å¤„ç†é”™è¯¯å“åº”ï¼ˆ400ã€404ç­‰ï¼‰
- [ ] èƒ½åœ¨å‰ç«¯è°ƒç”¨APIå¹¶æ›´æ–°UI

---

## Day 7ï¼šNext.js Middlewareå’Œè®¤è¯ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šMiddlewareåŸºç¡€

**å­¦ä¹ å†…å®¹ï¼š**
1. Middlewareæ¦‚å¿µå’Œä½œç”¨
2. è¯·æ±‚æ‹¦æˆªå’Œé‡å®šå‘
3. ä¿®æ”¹è¯·æ±‚å’Œå“åº”å¤´
4. è·¯å¾„åŒ¹é…é…ç½®

**å®è·µä»»åŠ¡ï¼š**
```typescript
// middleware.ts (é¡¹ç›®æ ¹ç›®å½•)

import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // ä»»åŠ¡1ï¼šè®°å½•è¯·æ±‚æ—¥å¿—
  console.log(`[${new Date().toISOString()}] ${request.method} ${request.url}`)

  // ä»»åŠ¡2ï¼šæ£€æŸ¥è®¤è¯ï¼ˆç®€å•ç¤ºä¾‹ï¼‰
  const token = request.cookies.get('auth-token')

  // å¦‚æœè®¿é—®/dashboardä¸”æœªç™»å½•ï¼Œé‡å®šå‘åˆ°/login
  if (request.nextUrl.pathname.startsWith('/dashboard') && !token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // ä»»åŠ¡3ï¼šæ·»åŠ è‡ªå®šä¹‰å“åº”å¤´
  const response = NextResponse.next()
  response.headers.set('x-middleware-processed', 'true')

  return response
}

// é…ç½®MiddlewareåŒ¹é…è·¯å¾„
export const config = {
  matcher: [
    '/dashboard/:path*',  // åŒ¹é…/dashboardåŠå…¶å­è·¯å¾„
    '/api/:path*'         // åŒ¹é…æ‰€æœ‰APIè·¯ç”±
  ]
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šç®€å•è®¤è¯å®ç°

**å®è·µä»»åŠ¡ï¼š**
```typescript
// app/api/auth/login/route.ts

import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  const { email, password } = await request.json()

  // ç®€å•éªŒè¯ï¼ˆå®é™…é¡¹ç›®ä¸­è¦åŠ å¯†å’ŒæŸ¥æ•°æ®åº“ï¼‰
  if (email === 'test@test.com' && password === 'password') {
    const response = NextResponse.json({
      success: true,
      user: { email, role: 'user' }
    })

    // è®¾ç½®cookieï¼ˆå®é™…é¡¹ç›®ä¸­ç”¨JWTï¼‰
    response.cookies.set('auth-token', 'simple-token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 60 * 60 * 24 // 1å¤©
    })

    return response
  }

  return NextResponse.json(
    { error: 'Invalid credentials' },
    { status: 401 }
  )
}
```

```typescript
// app/api/auth/logout/route.ts

import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  const response = NextResponse.json({ success: true })

  // æ¸…é™¤cookie
  response.cookies.delete('auth-token')

  return response
}
```

```typescript
// app/login/page.tsx

'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const router = useRouter()

  const handleLogin = async () => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    })

    if (res.ok) {
      router.push('/dashboard')
    } else {
      alert('Login failed')
    }
  }

  return (
    <div>
      <h1>Login</h1>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button onClick={handleLogin}>Login</button>
      <p>Hint: test@test.com / password</p>
    </div>
  )
}
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½åˆ›å»ºMiddlewareå¹¶é…ç½®åŒ¹é…è·¯å¾„
- [ ] èƒ½å®ç°ç®€å•çš„è·¯ç”±ä¿æŠ¤
- [ ] èƒ½å®ç°åŸºç¡€çš„ç™»å½•/ç™»å‡ºåŠŸèƒ½
- [ ] èƒ½ç†è§£cookieå’Œè®¤è¯æµç¨‹

**Week 1 æ€»ç»“ï¼š**
- [ ] å®ŒæˆTypeScriptåŸºç¡€å­¦ä¹ 
- [ ] æŒæ¡React Hooksï¼ˆuseStateã€useEffectã€useReducerï¼‰
- [ ] ç†è§£Next.jsè·¯ç”±å’ŒAPIç³»ç»Ÿ
- [ ] å®ç°ç®€å•çš„å…¨æ ˆåº”ç”¨

---

# Week 2ï¼šé¡¹ç›®æ ¸å¿ƒæµç¨‹ï¼ˆ42å°æ—¶ï¼‰

## Day 8ï¼šPrismaå’Œæ•°æ®åº“ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šPrismaåŸºç¡€

**å­¦ä¹ å†…å®¹ï¼š**
1. Prisma Schemaè¯­æ³•
2. æ¨¡å‹å®šä¹‰å’Œå…³ç³»
3. Prisma Client API
4. è¿ç§»å’Œç”Ÿæˆ

**æ¨èèµ„æºï¼š**
- Prismaå®˜æ–¹æ–‡æ¡£ï¼šhttps://www.prisma.io/docs/getting-started

**å®è·µä»»åŠ¡ï¼š**
```bash
# å›åˆ°é¡¹ç›®ç›®å½•
cd D:\zdqidongxiangmu

# æ‰“å¼€Prisma Schema
code prisma/schema.prisma
```

**ä»»åŠ¡1ï¼šé˜…è¯»å¹¶ç†è§£Schema**
```prisma
// prisma/schema.prisma

// å…³é”®æ¨¡å‹è§£è¯»ï¼š

// 1. Useræ¨¡å‹
model User {
  id                  String         @id @default(cuid())
  email               String         @unique
  displayName         String?
  role                UserRole       @default(USER)

  // é…é¢ç®¡ç†å­—æ®µ
  monthlyTokenLimit   Int            @default(100000)
  currentMonthUsage   Int            @default(0)
  usageResetDate      DateTime       @default(now())

  // å…³ç³»å­—æ®µ
  conversations       Conversation[]  // ä¸€ä¸ªç”¨æˆ·æœ‰å¤šä¸ªå¯¹è¯
  messages            Message[]       // å†—ä½™ï¼šä¸€ä¸ªç”¨æˆ·æœ‰å¤šä¸ªæ¶ˆæ¯

  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  // ç´¢å¼•ï¼šä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
  @@index([email])
}

// 2. Conversationæ¨¡å‹
model Conversation {
  id                  String         @id @default(cuid())
  title               String
  userId              String

  // å†—ä½™å­—æ®µï¼šä¼˜åŒ–æŸ¥è¯¢
  lastMessageAt       DateTime?      // æœ€åæ¶ˆæ¯æ—¶é—´ï¼ˆé¿å…JOINï¼‰
  messageCount        Int            @default(0)
  totalTokens         Int            @default(0)

  // å…³ç³»
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages            Message[]

  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  // å¤åˆç´¢å¼•ï¼šä¼˜åŒ–å¯¹è¯åˆ—è¡¨æŸ¥è¯¢
  @@index([userId, lastMessageAt(sort: Desc)])
}

// 3. Messageæ¨¡å‹
model Message {
  id                  String         @id @default(cuid())
  conversationId      String
  userId              String         // å†—ä½™ï¼šé¿å…JOINæŸ¥è¯¢é…é¢
  role                MessageRole
  content             String

  // Tokenç»Ÿè®¡
  promptTokens        Int            @default(0)
  completionTokens    Int            @default(0)

  // å…³ç³»
  conversation        Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt           DateTime       @default(now())

  // ç´¢å¼•
  @@index([conversationId, createdAt])
  @@index([userId])
}
```

**ä»»åŠ¡2ï¼šç†è§£å†—ä½™å­—æ®µè®¾è®¡**
åœ¨æ–‡æ¡£ä¸­è®°å½•ï¼š
```markdown
## å†—ä½™å­—æ®µè®¾è®¡ç†ç”±

### 1. Message.userId
- **å†—ä½™åŸå› **ï¼šæ¶ˆæ¯å·²ç»æœ‰conversationIdï¼Œé€šè¿‡conversationå¯ä»¥æ‰¾åˆ°userId
- **ä¸ºä»€ä¹ˆå†—ä½™**ï¼šç”¨æˆ·é…é¢ç»Ÿè®¡éœ€è¦é¢‘ç¹æŸ¥è¯¢ç”¨æˆ·çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œé¿å…JOINæå‡æ€§èƒ½
- **æŸ¥è¯¢å¯¹æ¯”**ï¼š
  - æ— å†—ä½™ï¼šSELECT * FROM Message JOIN Conversation ON ... WHERE Conversation.userId = ?
  - æœ‰å†—ä½™ï¼šSELECT * FROM Message WHERE userId = ? (å¿«10å€+)

### 2. Conversation.lastMessageAt
- **å†—ä½™åŸå› **ï¼šå¯ä»¥é€šè¿‡messageså…³ç³»æŸ¥æœ€æ–°æ¶ˆæ¯æ—¶é—´
- **ä¸ºä»€ä¹ˆå†—ä½™**ï¼šå¯¹è¯åˆ—è¡¨æŒ‰æœ€åæ¶ˆæ¯æ—¶é—´æ’åºæ˜¯é«˜é¢‘æ“ä½œ
- **æŸ¥è¯¢å¯¹æ¯”**ï¼š
  - æ— å†—ä½™ï¼šéœ€è¦JOIN messagesè¡¨å¹¶GROUP BY
  - æœ‰å†—ä½™ï¼šç›´æ¥ORDER BY lastMessageAt (å¿«100å€+)

### 3. Conversation.messageCount / totalTokens
- **å†—ä½™åŸå› **ï¼šå¯ä»¥é€šè¿‡COUNTå’ŒSUMå®æ—¶è®¡ç®—
- **ä¸ºä»€ä¹ˆå†—ä½™**ï¼šé¿å…æ¯æ¬¡æ˜¾ç¤ºå¯¹è¯åˆ—è¡¨éƒ½è¦èšåˆè®¡ç®—
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šPrisma Clientå®è·µ

**å®è·µä»»åŠ¡ï¼š**
```typescript
// scripts/test-prisma-basics.ts

import { prisma } from '../lib/prisma'

async function main() {
  console.log('=== PrismaåŸºç¡€æ“ä½œæµ‹è¯• ===\n')

  // ä»»åŠ¡1ï¼šåˆ›å»ºç”¨æˆ·
  console.log('1. åˆ›å»ºæµ‹è¯•ç”¨æˆ·...')
  const user = await prisma.user.create({
    data: {
      email: 'prisma-test@test.com',
      displayName: 'Prismaæµ‹è¯•ç”¨æˆ·',
      role: 'USER',
      monthlyTokenLimit: 50000
    }
  })
  console.log('åˆ›å»ºæˆåŠŸ:', user)

  // ä»»åŠ¡2ï¼šåˆ›å»ºå¯¹è¯ï¼ˆå¸¦å…³ç³»ï¼‰
  console.log('\n2. åˆ›å»ºå¯¹è¯...')
  const conversation = await prisma.conversation.create({
    data: {
      title: 'æµ‹è¯•å¯¹è¯',
      userId: user.id,
      messages: {
        create: [
          {
            role: 'user',
            content: 'Hello',
            userId: user.id,
            promptTokens: 5
          },
          {
            role: 'assistant',
            content: 'Hi there!',
            userId: user.id,
            completionTokens: 10
          }
        ]
      }
    },
    include: {
      messages: true // åŒ…å«å…³è”çš„æ¶ˆæ¯
    }
  })
  console.log('åˆ›å»ºæˆåŠŸ:', conversation)

  // ä»»åŠ¡3ï¼šæŸ¥è¯¢ç”¨æˆ·çš„æ‰€æœ‰å¯¹è¯ï¼ˆå¸¦æ¶ˆæ¯æ•°ï¼‰
  console.log('\n3. æŸ¥è¯¢ç”¨æˆ·å¯¹è¯...')
  const userConversations = await prisma.conversation.findMany({
    where: { userId: user.id },
    include: {
      _count: {
        select: { messages: true }
      }
    },
    orderBy: { lastMessageAt: 'desc' }
  })
  console.log('ç”¨æˆ·å¯¹è¯:', userConversations)

  // ä»»åŠ¡4ï¼šèšåˆæŸ¥è¯¢ï¼ˆç»Ÿè®¡tokenä½¿ç”¨ï¼‰
  console.log('\n4. ç»Ÿè®¡Tokenä½¿ç”¨...')
  const tokenStats = await prisma.message.aggregate({
    where: { userId: user.id },
    _sum: {
      promptTokens: true,
      completionTokens: true
    },
    _count: true
  })
  console.log('Tokenç»Ÿè®¡:', tokenStats)

  // ä»»åŠ¡5ï¼šäº‹åŠ¡æ“ä½œï¼ˆåŸå­æ€§ï¼‰
  console.log('\n5. äº‹åŠ¡æ“ä½œ...')
  await prisma.$transaction(async (tx) => {
    // æ›´æ–°ç”¨æˆ·é…é¢
    await tx.user.update({
      where: { id: user.id },
      data: { currentMonthUsage: { increment: 100 } }
    })

    // æ›´æ–°å¯¹è¯ç»Ÿè®¡
    await tx.conversation.update({
      where: { id: conversation.id },
      data: {
        messageCount: { increment: 1 },
        totalTokens: { increment: 100 }
      }
    })
  })
  console.log('äº‹åŠ¡æ‰§è¡ŒæˆåŠŸ')

  // æ¸…ç†æµ‹è¯•æ•°æ®
  console.log('\n6. æ¸…ç†æµ‹è¯•æ•°æ®...')
  await prisma.user.delete({ where: { id: user.id } })
  console.log('æ¸…ç†å®Œæˆ')
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**è¿è¡Œæµ‹è¯•ï¼š**
```bash
npx tsx scripts/test-prisma-basics.ts
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠUserã€Conversationã€Messageçš„å…³ç³»
- [ ] èƒ½ç†è§£3ä¸ªå†—ä½™å­—æ®µçš„è®¾è®¡ç†ç”±
- [ ] èƒ½ä½¿ç”¨Prisma Clientè¿›è¡ŒCRUDæ“ä½œ
- [ ] èƒ½ç†è§£äº‹åŠ¡çš„ä½œç”¨

---

## Day 9ï¼šæ•°æ®åº“ç´¢å¼•å’Œæ€§èƒ½ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šç´¢å¼•ç­–ç•¥

**å­¦ä¹ å†…å®¹ï¼š**
1. æ•°æ®åº“ç´¢å¼•åŸç†
2. å•åˆ—ç´¢å¼• vs å¤åˆç´¢å¼•
3. ç´¢å¼•è¦†ç›–æŸ¥è¯¢
4. ç´¢å¼•çš„æƒè¡¡

**å®è·µä»»åŠ¡ï¼š**
```typescript
// scripts/test-index-performance.ts

import { prisma } from '../lib/prisma'

async function testIndexPerformance() {
  console.log('=== ç´¢å¼•æ€§èƒ½æµ‹è¯• ===\n')

  // å‡†å¤‡æµ‹è¯•æ•°æ®ï¼šåˆ›å»º1ä¸ªç”¨æˆ·å’Œ100ä¸ªå¯¹è¯
  console.log('å‡†å¤‡æµ‹è¯•æ•°æ®...')
  const user = await prisma.user.create({
    data: {
      email: 'index-test@test.com',
      displayName: 'ç´¢å¼•æµ‹è¯•ç”¨æˆ·'
    }
  })

  // æ‰¹é‡åˆ›å»ºå¯¹è¯
  const conversations = []
  for (let i = 0; i < 100; i++) {
    conversations.push({
      title: `å¯¹è¯ ${i}`,
      userId: user.id,
      lastMessageAt: new Date(Date.now() - i * 1000 * 60 * 60) // æ¯ä¸ªå¯¹è¯é—´éš”1å°æ—¶
    })
  }

  await prisma.conversation.createMany({ data: conversations })

  // æµ‹è¯•1ï¼šæœ‰ç´¢å¼•çš„æŸ¥è¯¢ï¼ˆä½¿ç”¨å¤åˆç´¢å¼•ï¼‰
  console.log('\næµ‹è¯•1ï¼šæŒ‰userIdå’ŒlastMessageAtæ’åºæŸ¥è¯¢ï¼ˆæœ‰ç´¢å¼•ï¼‰')
  const start1 = Date.now()
  const result1 = await prisma.conversation.findMany({
    where: { userId: user.id },
    orderBy: { lastMessageAt: 'desc' },
    take: 20
  })
  const time1 = Date.now() - start1
  console.log(`æŸ¥è¯¢æ—¶é—´: ${time1}ms, ç»“æœæ•°: ${result1.length}`)
  console.log('ä½¿ç”¨çš„ç´¢å¼•: [userId, lastMessageAt(sort: Desc)]')

  // æµ‹è¯•2ï¼šè§£é‡ŠæŸ¥è¯¢è®¡åˆ’ï¼ˆSQLiteï¼‰
  console.log('\næµ‹è¯•2ï¼šæŸ¥çœ‹æŸ¥è¯¢è®¡åˆ’...')
  const explain = await prisma.$queryRaw`
    EXPLAIN QUERY PLAN
    SELECT * FROM Conversation
    WHERE userId = ${user.id}
    ORDER BY lastMessageAt DESC
    LIMIT 20
  `
  console.log('æŸ¥è¯¢è®¡åˆ’:', explain)

  // æ¸…ç†
  await prisma.user.delete({ where: { id: user.id } })
  console.log('\næµ‹è¯•å®Œæˆï¼Œæ•°æ®å·²æ¸…ç†')
}

testIndexPerformance()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**ç†è§£ç´¢å¼•é…ç½®ï¼š**
```prisma
model Conversation {
  // ...å­—æ®µå®šä¹‰

  // å¤åˆç´¢å¼•ï¼šä¼˜åŒ–å¯¹è¯åˆ—è¡¨æŸ¥è¯¢
  // WHERE userId = ? ORDER BY lastMessageAt DESC
  @@index([userId, lastMessageAt(sort: Desc)])

  // è¿™ä¸ªç´¢å¼•æ”¯æŒä»¥ä¸‹æŸ¥è¯¢ï¼š
  // 1. WHERE userId = ?
  // 2. WHERE userId = ? ORDER BY lastMessageAt
  // 3. WHERE userId = ? ORDER BY lastMessageAt DESC
}

model Message {
  // ...å­—æ®µå®šä¹‰

  // ç´¢å¼•1ï¼šä¼˜åŒ–è·å–å¯¹è¯æ¶ˆæ¯
  @@index([conversationId, createdAt])

  // ç´¢å¼•2ï¼šä¼˜åŒ–ç”¨æˆ·é…é¢ç»Ÿè®¡
  @@index([userId])
}
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šPrisma Studioå®æˆ˜

**å®è·µä»»åŠ¡ï¼š**
```bash
# å¯åŠ¨Prisma Studio
pnpm db:studio
```

**ä»»åŠ¡æ¸…å•ï¼š**
1. **æµè§ˆæ‰€æœ‰è¡¨**
   - [ ] æŸ¥çœ‹Userè¡¨ç»“æ„å’Œæ•°æ®
   - [ ] æŸ¥çœ‹Conversationè¡¨ç»“æ„å’Œæ•°æ®
   - [ ] æŸ¥çœ‹Messageè¡¨ç»“æ„å’Œæ•°æ®
   - [ ] ç†è§£è¡¨ä¹‹é—´çš„å…³ç³»

2. **æ‰‹åŠ¨åˆ›å»ºæ•°æ®**
   - [ ] åˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨æˆ·
   - [ ] ä¸ºè¯¥ç”¨æˆ·åˆ›å»ºä¸€ä¸ªå¯¹è¯
   - [ ] ä¸ºè¯¥å¯¹è¯åˆ›å»ºå‡ æ¡æ¶ˆæ¯
   - [ ] è§‚å¯Ÿå†—ä½™å­—æ®µï¼ˆlastMessageAtç­‰ï¼‰æ˜¯å¦æ­£ç¡®

3. **æµ‹è¯•çº§è”åˆ é™¤**
   - [ ] åˆ é™¤ä¸€ä¸ªå¯¹è¯
   - [ ] ç¡®è®¤å…³è”çš„æ¶ˆæ¯ä¹Ÿè¢«åˆ é™¤
   - [ ] ç†è§£onDelete: Cascadeçš„ä½œç”¨

4. **éªŒè¯ç´¢å¼•æ•ˆæœ**
   - [ ] åˆ›å»º50+æ¡å¯¹è¯
   - [ ] åœ¨Studioä¸­æŒ‰lastMessageAtæ’åº
   - [ ] è§‚å¯ŸæŸ¥è¯¢é€Ÿåº¦

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡Šå¤åˆç´¢å¼•çš„å·¥ä½œåŸç†
- [ ] èƒ½è§£é‡Šç´¢å¼•è¦†ç›–æŸ¥è¯¢
- [ ] èƒ½ä½¿ç”¨Prisma Studioç®¡ç†æ•°æ®
- [ ] èƒ½ç†è§£çº§è”åˆ é™¤

---

## Day 10-11ï¼šè®¤è¯ç³»ç»Ÿæ·±å…¥ï¼ˆ12å°æ—¶ï¼‰

### Day 10ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šNextAuth.jsæ·±å…¥

**å­¦ä¹ å†…å®¹ï¼š**
1. NextAuth.jsæ¶æ„
2. Provideræ¦‚å¿µ
3. Sessionå’ŒJWTç­–ç•¥
4. Callbacksï¼ˆjwtã€sessionï¼‰

**æ¨èèµ„æºï¼š**
- NextAuth.jsæ–‡æ¡£ï¼šhttps://next-auth.js.org/getting-started/introduction

**å®è·µä»»åŠ¡ï¼š**
```bash
# æ‰“å¼€é¡¹ç›®è®¤è¯æ–‡ä»¶
code auth.ts
code auth/strategies/index.ts
code middleware.ts
```

**ä»»åŠ¡1ï¼šç†è§£è®¤è¯æµç¨‹**
```typescript
// auth.ts å…³é”®ä»£ç è§£è¯»

import NextAuth from 'next-auth'
import Credentials from 'next-auth/providers/credentials'
import { selectAuthStrategy } from './auth/strategies'

export const { handlers, signIn, signOut, auth } = NextAuth({
  // 1. Provideré…ç½®
  providers: [
    Credentials({
      credentials: {
        email: { label: 'Email', type: 'email' },
        code: { label: 'Code', type: 'password' }
      },
      // 2. è®¤è¯é€»è¾‘
      async authorize(credentials) {
        const strategy = selectAuthStrategy()
        return await strategy.authenticate(credentials)
      }
    })
  ],

  // 3. Sessionç­–ç•¥ï¼šJWTï¼ˆæ— éœ€æ•°æ®åº“ï¼‰
  session: { strategy: 'jwt' },

  // 4. JWTå›è°ƒï¼šå°†ç”¨æˆ·ä¿¡æ¯æ³¨å…¥token
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        // ç™»å½•æ—¶ï¼šå°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥token
        token.userId = user.id
        token.role = user.role
        token.monthlyTokenLimit = user.monthlyTokenLimit
      }
      return token
    },

    // 5. Sessionå›è°ƒï¼šå°†tokenä¿¡æ¯æš´éœ²ç»™å®¢æˆ·ç«¯
    async session({ session, token }) {
      if (token) {
        session.user.id = token.userId
        session.user.role = token.role
        session.user.monthlyTokenLimit = token.monthlyTokenLimit
      }
      return session
    }
  }
})
```

**ç”»å‡ºè®¤è¯æµç¨‹å›¾ï¼š**
```
ç”¨æˆ·ç™»å½•
  â†“
1. å‰ç«¯è°ƒç”¨ signIn('credentials', { email, code })
  â†“
2. NextAuthè°ƒç”¨ authorize(credentials)
  â†“
3. selectAuthStrategy() é€‰æ‹©ç­–ç•¥
  â”œâ”€ å¼€å‘ç¯å¢ƒï¼šdevelopmentAuth
  â”‚   â”œâ”€ éªŒè¯ DEV_LOGIN_CODE
  â”‚   â”œâ”€ æŸ¥è¯¢æˆ–åˆ›å»ºç”¨æˆ·
  â”‚   â””â”€ è¿”å› Userå¯¹è±¡
  â””â”€ ç”Ÿäº§ç¯å¢ƒï¼šproductionAuth
      â”œâ”€ éªŒè¯ ADMIN_LOGIN_PASSWORD
      â”œâ”€ ä»…æŸ¥è¯¢å·²å­˜åœ¨ç”¨æˆ·
      â””â”€ è¿”å› Userå¯¹è±¡æˆ–null
  â†“
4. å¦‚æœè¿”å›Userå¯¹è±¡ï¼Œè§¦å‘ jwt callback
  â”œâ”€ å°†userIdã€roleç­‰ä¿¡æ¯å­˜å…¥JWT token
  â””â”€ è¿”å›åŒ…å«ç”¨æˆ·ä¿¡æ¯çš„token
  â†“
5. è§¦å‘ session callback
  â”œâ”€ ä»tokenæå–ä¿¡æ¯
  â””â”€ æ³¨å…¥åˆ°session.user
  â†“
6. å‰ç«¯è·å¾—sessionï¼Œç™»å½•æˆåŠŸ
```

### Day 10ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šåŒæ¨¡å¼è®¤è¯ç­–ç•¥

**å®è·µä»»åŠ¡ï¼š**
```typescript
// auth/strategies/development.ts è§£è¯»

import { prisma } from '@/lib/prisma'

export const developmentAuth = {
  async authenticate(credentials: any) {
    const { email, code } = credentials

    // éªŒè¯å¼€å‘ç¯å¢ƒè®¤è¯ç 
    if (code !== process.env.DEV_LOGIN_CODE) {
      return null
    }

    // æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·ï¼ˆè‡ªåŠ¨æ³¨å†Œï¼‰
    let user = await prisma.user.findUnique({
      where: { email }
    })

    if (!user) {
      // å¼€å‘ç¯å¢ƒï¼šè‡ªåŠ¨åˆ›å»ºç”¨æˆ·
      user = await prisma.user.create({
        data: {
          email,
          displayName: email.split('@')[0],
          role: 'USER',
          monthlyTokenLimit: 100000
        }
      })
      console.log('[Dev Auth] è‡ªåŠ¨åˆ›å»ºç”¨æˆ·:', email)
    }

    return user
  }
}
```

```typescript
// auth/strategies/production.ts è§£è¯»

import { prisma } from '@/lib/prisma'

export const productionAuth = {
  async authenticate(credentials: any) {
    const { email, code } = credentials

    // éªŒè¯ç”Ÿäº§ç¯å¢ƒå¯†ç 
    if (code !== process.env.ADMIN_LOGIN_PASSWORD) {
      return null
    }

    // åªæŸ¥è¯¢å·²å­˜åœ¨çš„ç”¨æˆ·ï¼ˆä¸è‡ªåŠ¨åˆ›å»ºï¼‰
    const user = await prisma.user.findUnique({
      where: { email }
    })

    if (!user) {
      console.log('[Prod Auth] ç”¨æˆ·ä¸å­˜åœ¨:', email)
      return null
    }

    return user
  }
}
```

**ä»»åŠ¡ï¼šå†™ä¸€ä¸ªæµ‹è¯•è„šæœ¬**
```typescript
// scripts/test-auth-strategies.ts

import { selectAuthStrategy } from '../auth/strategies'

async function testAuthStrategies() {
  console.log('=== è®¤è¯ç­–ç•¥æµ‹è¯• ===\n')

  // æµ‹è¯•å½“å‰ç¯å¢ƒç­–ç•¥
  const strategy = selectAuthStrategy()
  console.log('å½“å‰ç­–ç•¥:', strategy)

  // æµ‹è¯•å¼€å‘ç¯å¢ƒè®¤è¯
  console.log('\næµ‹è¯•1ï¼šå¼€å‘ç¯å¢ƒè®¤è¯')
  console.log('ç¯å¢ƒå˜é‡ DEV_LOGIN_CODE:', process.env.DEV_LOGIN_CODE)

  const devResult = await strategy.authenticate({
    email: 'newuser@test.com',
    code: process.env.DEV_LOGIN_CODE
  })
  console.log('è®¤è¯ç»“æœ:', devResult ? 'æˆåŠŸ' : 'å¤±è´¥')
  if (devResult) {
    console.log('ç”¨æˆ·ä¿¡æ¯:', {
      email: devResult.email,
      role: devResult.role,
      limit: devResult.monthlyTokenLimit
    })
  }

  // æµ‹è¯•é”™è¯¯è®¤è¯ç 
  console.log('\næµ‹è¯•2ï¼šé”™è¯¯è®¤è¯ç ')
  const failResult = await strategy.authenticate({
    email: 'test@test.com',
    code: 'wrong-code'
  })
  console.log('è®¤è¯ç»“æœ:', failResult ? 'æˆåŠŸ' : 'å¤±è´¥ï¼ˆé¢„æœŸï¼‰')
}

testAuthStrategies()
  .catch(console.error)
  .finally(() => process.exit())
```

### Day 11ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šMiddlewareè·¯ç”±ä¿æŠ¤

**å®è·µä»»åŠ¡ï¼š**
```typescript
// middleware.ts è¯¦ç»†è§£è¯»

import { NextRequest, NextResponse } from 'next/server'
import { auth } from './auth'

// å…¬å¼€è·¯å¾„ï¼šä¸éœ€è¦è®¤è¯
const publicPaths = [
  '/',
  '/login',
  '/api/auth',
  '/_next',
  '/favicon.ico'
]

export default async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl

  // 1. æ£€æŸ¥æ˜¯å¦æ˜¯å…¬å¼€è·¯å¾„
  const isPublicPath = publicPaths.some(path =>
    pathname.startsWith(path)
  )

  if (isPublicPath) {
    return NextResponse.next()
  }

  // 2. éªŒè¯JWT token
  const session = await auth()

  // 3. æœªç™»å½•ï¼šé‡å®šå‘åˆ°ç™»å½•é¡µ
  if (!session?.user) {
    const loginUrl = new URL('/login', req.url)
    loginUrl.searchParams.set('callbackUrl', pathname) // è®°ä½åŸå§‹è·¯å¾„
    return NextResponse.redirect(loginUrl)
  }

  // 4. å·²ç™»å½•ï¼šæ³¨å…¥userIdåˆ°headerï¼ˆä¾›APIä½¿ç”¨ï¼‰
  const response = NextResponse.next()
  response.headers.set('x-user-id', session.user.id)
  response.headers.set('x-user-role', session.user.role)

  return response
}

// é…ç½®ï¼šå¯¹æ‰€æœ‰è·¯å¾„ç”Ÿæ•ˆï¼Œä½†publicPathsé™¤å¤–
export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico).*)'
  ]
}
```

**ç†è§£å…³é”®ç‚¹ï¼š**
```typescript
// ä¸ºä»€ä¹ˆè¦æ³¨å…¥headerï¼Ÿ
// å› ä¸ºAPIè·¯ç”±ä¸­éœ€è¦çŸ¥é“å½“å‰ç”¨æˆ·IDï¼Œä½†æ— æ³•ç›´æ¥è®¿é—®session

// app/api/chat/route.ts
export async function POST(req: NextRequest) {
  // æ–¹å¼1ï¼šä»headerè·å–ï¼ˆMiddlewareæ³¨å…¥ï¼‰
  const userId = req.headers.get('x-user-id')

  // æ–¹å¼2ï¼šé‡æ–°éªŒè¯token
  const session = await auth()
  const userId2 = session?.user?.id

  // é¡¹ç›®ä¸­ä½¿ç”¨æ–¹å¼2ï¼ˆæ›´å®‰å…¨ï¼‰
}
```

### Day 11ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šå®Œæ•´è®¤è¯æµç¨‹å®è·µ

**å®è·µä»»åŠ¡ï¼šæµ‹è¯•å®Œæ•´ç™»å½•æµç¨‹**

1. **åˆ›å»ºæµ‹è¯•ç”¨æˆ·**
```bash
npx tsx scripts/create-user.ts auth-test@test.com "è®¤è¯æµ‹è¯•" USER 50000
```

2. **æµ‹è¯•ç™»å½•æµç¨‹**
```bash
# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
pnpm dev

# æµè§ˆå™¨è®¿é—®
http://localhost:3007/login
```

3. **è§‚å¯Ÿè®¤è¯æµç¨‹**
- [ ] æ‰“å¼€æµè§ˆå™¨å¼€å‘è€…å·¥å…·ï¼ˆF12ï¼‰
- [ ] Networkæ ‡ç­¾é¡µ
- [ ] è¾“å…¥é‚®ç®±å’Œè®¤è¯ç ï¼Œç‚¹å‡»ç™»å½•
- [ ] è§‚å¯Ÿè¯·æ±‚ï¼š
  - `POST /api/auth/signin` - ç™»å½•è¯·æ±‚
  - å“åº”ï¼šè®¾ç½®cookie `authjs.session-token`
  - é‡å®šå‘åˆ°é¦–é¡µæˆ–callbackUrl

4. **éªŒè¯Session**
```typescript
// åœ¨ä»»æ„å®¢æˆ·ç«¯ç»„ä»¶ä¸­
'use client'

import { useSession } from 'next-auth/react'

export default function TestSession() {
  const { data: session, status } = useSession()

  if (status === 'loading') return <div>Loading...</div>
  if (status === 'unauthenticated') return <div>æœªç™»å½•</div>

  return (
    <div>
      <h2>å½“å‰ç”¨æˆ·</h2>
      <pre>{JSON.stringify(session.user, null, 2)}</pre>
    </div>
  )
}
```

5. **æµ‹è¯•è·¯ç”±ä¿æŠ¤**
- [ ] ç™»å‡ºåè®¿é—® `/chat` - åº”è¯¥é‡å®šå‘åˆ° `/login`
- [ ] ç™»å½•åè®¿é—® `/chat` - æ­£å¸¸æ˜¾ç¤º

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠJWTå’ŒSessionç­–ç•¥çš„åŒºåˆ«
- [ ] èƒ½è§£é‡ŠåŒæ¨¡å¼è®¤è¯çš„è®¾è®¡ç†ç”±
- [ ] èƒ½è§£é‡ŠMiddlewareçš„ä½œç”¨
- [ ] èƒ½ç‹¬ç«‹æµ‹è¯•å®Œæ•´è®¤è¯æµç¨‹

---

## Day 12-14ï¼šèŠå¤©APIå®Œæ•´é“¾è·¯ï¼ˆ18å°æ—¶ï¼‰

### Day 12ï¼šé…é¢ç®¡ç†ç³»ç»Ÿï¼ˆ6å°æ—¶ï¼‰

**é‡è¦æç¤º**ï¼šè¿™æ˜¯æ•´ä¸ªé¡¹ç›®æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ä¹‹ä¸€ï¼ŒåŠ¡å¿…ç†è§£é€å½»ï¼

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šåŸå­æ€§æ“ä½œåŸç†

**å­¦ä¹ å†…å®¹ï¼š**
1. ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰
2. æ•°æ®åº“åŸå­æ“ä½œ
3. ä¹è§‚é” vs æ‚²è§‚é”
4. SQLæ¡ä»¶æ›´æ–°

**æ ¸å¿ƒæ¦‚å¿µï¼šä¸ºä»€ä¹ˆéœ€è¦åŸå­æ€§ï¼Ÿ**
```typescript
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šè¯»-æ£€æŸ¥-å†™ï¼ˆRace Conditionï¼‰
async function wrongReserveTokens(userId: string, tokens: number) {
  // æ­¥éª¤1ï¼šè¯»å–å½“å‰ä½¿ç”¨é‡
  const user = await prisma.user.findUnique({ where: { id: userId } })

  // æ­¥éª¤2ï¼šæ£€æŸ¥æ˜¯å¦è¶…é™
  if (user.currentMonthUsage + tokens > user.monthlyTokenLimit) {
    throw new Error('é…é¢ä¸è¶³')
  }

  // æ­¥éª¤3ï¼šæ›´æ–°ä½¿ç”¨é‡
  await prisma.user.update({
    where: { id: userId },
    data: { currentMonthUsage: user.currentMonthUsage + tokens }
  })
}

// é—®é¢˜ï¼šå¦‚æœä¸¤ä¸ªè¯·æ±‚åŒæ—¶æ‰§è¡Œï¼Œå¯èƒ½éƒ½é€šè¿‡æ£€æŸ¥ï¼Œå¯¼è‡´è¶…é™
// è¯·æ±‚A: è¯»å–usage=8000 â†’ æ£€æŸ¥8000+3000=11000 > 10000? å¦ â†’ æ›´æ–°ä¸º11000
// è¯·æ±‚B: è¯»å–usage=8000 â†’ æ£€æŸ¥8000+3000=11000 > 10000? å¦ â†’ æ›´æ–°ä¸º11000
// ç»“æœï¼šusageå˜æˆ14000ï¼Œè¶…è¿‡é™åˆ¶ï¼
```

```typescript
// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šåŸå­æ€§æ¡ä»¶æ›´æ–°
async function correctReserveTokens(userId: string, tokens: number) {
  const result = await prisma.user.updateMany({
    where: {
      id: userId,
      // å…³é”®ï¼šåœ¨WHEREå­å¥ä¸­æ£€æŸ¥æ¡ä»¶
      currentMonthUsage: {
        lte: prisma.raw`monthlyTokenLimit - ${tokens}`
      }
    },
    data: {
      currentMonthUsage: { increment: tokens }
    }
  })

  // å¦‚æœcount=0ï¼Œè¯´æ˜æ›´æ–°å¤±è´¥ï¼ˆè¶…é™ï¼‰
  if (result.count === 0) {
    throw new Error('é…é¢ä¸è¶³')
  }
}

// ä¼˜ç‚¹ï¼šæ•°æ®åº“ä¿è¯åŸå­æ€§ï¼Œä¸ä¼šå‡ºç°ç«æ€æ¡ä»¶
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šQuotaManageræ·±å…¥

**å®è·µä»»åŠ¡ï¼š**
```bash
# æ‰“å¼€é…é¢ç®¡ç†å™¨
code lib/security/quota-manager.ts
```

**è¯¦ç»†é˜…è¯»å¹¶æ·»åŠ æ³¨é‡Šï¼š**
```typescript
// lib/security/quota-manager.ts å…³é”®ä»£ç è§£è¯»

export class QuotaManager {
  // æ–¹æ³•1ï¼šé¢„ç•™é…é¢ï¼ˆåŸå­æ€§æ“ä½œï¼‰
  async reserveTokens(userId: string, estimatedTokens: number): Promise<void> {
    // æ­¥éª¤1ï¼šæ£€æŸ¥å¹¶é‡ç½®æœˆåº¦é…é¢ï¼ˆå¦‚æœéœ€è¦ï¼‰
    await this.checkAndResetMonthlyUsage(userId)

    // æ­¥éª¤2ï¼šåŸå­æ€§æ›´æ–°ï¼ˆä½¿ç”¨PrismaåŸç”ŸSQLï¼‰
    const result = await prisma.$executeRaw`
      UPDATE User
      SET currentMonthUsage = currentMonthUsage + ${estimatedTokens}
      WHERE id = ${userId}
      AND currentMonthUsage + ${estimatedTokens} <= monthlyTokenLimit
    `

    // æ­¥éª¤3ï¼šæ£€æŸ¥æ›´æ–°ç»“æœ
    if (result === 0) {
      throw new QuotaExceededError('æœˆåº¦é…é¢å·²ç”¨å®Œ')
    }

    console.log(`[Quota] é¢„ç•™æˆåŠŸ: userId=${userId}, tokens=${estimatedTokens}`)
  }

  // æ–¹æ³•2ï¼šæäº¤å®é™…ä½¿ç”¨é‡ï¼ˆäº‹åŠ¡ï¼‰
  async commitTokens(
    userId: string,
    actualTokens: number,
    estimatedTokens: number,
    messageData: any
  ): Promise<void> {
    const adjustment = actualTokens - estimatedTokens

    // ä½¿ç”¨äº‹åŠ¡ç¡®ä¿ä¸€è‡´æ€§
    await prisma.$transaction(async (tx) => {
      // æ­¥éª¤1ï¼šåˆ›å»ºæ¶ˆæ¯è®°å½•
      await tx.message.create({
        data: {
          ...messageData,
          promptTokens: messageData.role === 'user' ? actualTokens : 0,
          completionTokens: messageData.role === 'assistant' ? actualTokens : 0
        }
      })

      // æ­¥éª¤2ï¼šè°ƒæ•´ç”¨æˆ·é…é¢ï¼ˆæŒ‰å·®é¢ï¼‰
      if (adjustment !== 0) {
        await tx.user.update({
          where: { id: userId },
          data: { currentMonthUsage: { increment: adjustment } }
        })
      }

      // æ­¥éª¤3ï¼šæ›´æ–°å¯¹è¯ç»Ÿè®¡
      await tx.conversation.update({
        where: { id: messageData.conversationId },
        data: {
          messageCount: { increment: 1 },
          totalTokens: { increment: actualTokens },
          lastMessageAt: new Date()
        }
      })
    })

    console.log(`[Quota] æäº¤æˆåŠŸ: actual=${actualTokens}, adjustment=${adjustment}`)
  }

  // æ–¹æ³•3ï¼šé‡Šæ”¾é…é¢ï¼ˆå¤±è´¥å›æ»šï¼‰
  async releaseTokens(userId: string, tokens: number): Promise<void> {
    await prisma.user.update({
      where: { id: userId },
      data: { currentMonthUsage: { decrement: tokens } }
    })

    console.log(`[Quota] é‡Šæ”¾æˆåŠŸ: userId=${userId}, tokens=${tokens}`)
  }

  // æ–¹æ³•4ï¼šæœˆåº¦é‡ç½®æ£€æŸ¥
  private async checkAndResetMonthlyUsage(userId: string): Promise<void> {
    const user = await prisma.user.findUnique({ where: { id: userId } })
    if (!user) return

    const now = new Date()
    const resetDate = new Date(user.usageResetDate)

    // å¦‚æœè¶…è¿‡1ä¸ªæœˆï¼Œé‡ç½®
    if (now.getTime() - resetDate.getTime() > 30 * 24 * 60 * 60 * 1000) {
      await prisma.user.update({
        where: { id: userId },
        data: {
          currentMonthUsage: 0,
          usageResetDate: now
        }
      })
      console.log(`[Quota] æœˆåº¦é‡ç½®: userId=${userId}`)
    }
  }
}

export const quotaManager = new QuotaManager()
```

**ç¼–å†™æµ‹è¯•è„šæœ¬ï¼š**
```typescript
// scripts/test-quota-manager.ts

import { quotaManager } from '../lib/security/quota-manager'
import { prisma } from '../lib/prisma'

async function testQuotaManager() {
  console.log('=== é…é¢ç®¡ç†å™¨æµ‹è¯• ===\n')

  // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
  const user = await prisma.user.create({
    data: {
      email: 'quota-test@test.com',
      displayName: 'é…é¢æµ‹è¯•',
      monthlyTokenLimit: 1000,
      currentMonthUsage: 0
    }
  })
  console.log('åˆ›å»ºæµ‹è¯•ç”¨æˆ·:', user.email)

  try {
    // æµ‹è¯•1ï¼šé¢„ç•™é…é¢ï¼ˆæˆåŠŸï¼‰
    console.log('\næµ‹è¯•1ï¼šé¢„ç•™500 tokensï¼ˆåº”è¯¥æˆåŠŸï¼‰')
    await quotaManager.reserveTokens(user.id, 500)
    const user1 = await prisma.user.findUnique({ where: { id: user.id } })
    console.log('å½“å‰ä½¿ç”¨é‡:', user1?.currentMonthUsage) // åº”è¯¥æ˜¯500

    // æµ‹è¯•2ï¼šé¢„ç•™é…é¢ï¼ˆæˆåŠŸï¼‰
    console.log('\næµ‹è¯•2ï¼šå†é¢„ç•™400 tokensï¼ˆåº”è¯¥æˆåŠŸï¼‰')
    await quotaManager.reserveTokens(user.id, 400)
    const user2 = await prisma.user.findUnique({ where: { id: user.id } })
    console.log('å½“å‰ä½¿ç”¨é‡:', user2?.currentMonthUsage) // åº”è¯¥æ˜¯900

    // æµ‹è¯•3ï¼šé¢„ç•™é…é¢ï¼ˆå¤±è´¥ - è¶…é™ï¼‰
    console.log('\næµ‹è¯•3ï¼šå°è¯•é¢„ç•™200 tokensï¼ˆåº”è¯¥å¤±è´¥ï¼‰')
    try {
      await quotaManager.reserveTokens(user.id, 200)
      console.log('âŒ æµ‹è¯•å¤±è´¥ï¼šåº”è¯¥æŠ›å‡ºé”™è¯¯')
    } catch (error) {
      console.log('âœ… æ­£ç¡®æŠ›å‡ºé”™è¯¯:', (error as Error).message)
    }

    // æµ‹è¯•4ï¼šé‡Šæ”¾é…é¢
    console.log('\næµ‹è¯•4ï¼šé‡Šæ”¾500 tokens')
    await quotaManager.releaseTokens(user.id, 500)
    const user4 = await prisma.user.findUnique({ where: { id: user.id } })
    console.log('å½“å‰ä½¿ç”¨é‡:', user4?.currentMonthUsage) // åº”è¯¥æ˜¯400

    console.log('\nâœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡')
  } finally {
    // æ¸…ç†
    await prisma.user.delete({ where: { id: user.id } })
    console.log('\næµ‹è¯•æ•°æ®å·²æ¸…ç†')
  }
}

testQuotaManager()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**è¿è¡Œæµ‹è¯•ï¼š**
```bash
npx tsx scripts/test-quota-manager.ts
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡Šç«æ€æ¡ä»¶çš„é—®é¢˜
- [ ] èƒ½è§£é‡ŠåŸå­æ€§SQLæ›´æ–°çš„åŸç†
- [ ] èƒ½è§£é‡Šäº‹åŠ¡çš„ä½œç”¨
- [ ] èƒ½è§£é‡Šé¢„ç•™-æäº¤-å›æ»šçš„ä¸‰æ­¥æ¨¡å¼

---

### Day 13ï¼šä¸Šä¸‹æ–‡è£å‰ªå’ŒSSEåŸºç¡€ï¼ˆ6å°æ—¶ï¼‰

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šä¸Šä¸‹æ–‡è£å‰ªå™¨

**å®è·µä»»åŠ¡ï¼š**
```bash
# æ‰“å¼€ä¸Šä¸‹æ–‡è£å‰ªå™¨
code lib/chat/context-trimmer.ts
code lib/constants/message-limits.ts
```

**è¯¦ç»†é˜…è¯»ï¼š**
```typescript
// lib/constants/message-limits.ts

export const MESSAGE_LIMITS = {
  // ä¸åŒæ¨¡å‹çš„ä¸Šä¸‹æ–‡é™åˆ¶
  'claude-opus-4': {
    maxContextTokens: 180000,  // APIè°ƒç”¨é™åˆ¶
    displayTokens: 500000,     // ç•Œé¢æ˜¾ç¤ºé™åˆ¶
    estimateRatio: 1.5         // ä¸­æ–‡å­—ç¬¦/tokenæ¯”ç‡
  },
  'gpt-4': {
    maxContextTokens: 120000,
    displayTokens: 120000,
    estimateRatio: 2
  },
  // é»˜è®¤é…ç½®
  default: {
    maxContextTokens: 100000,
    displayTokens: 100000,
    estimateRatio: 2
  }
}
```

```typescript
// lib/chat/context-trimmer.ts

import { ChatMessage } from '@/types/chat'
import { MESSAGE_LIMITS } from '@/lib/constants/message-limits'

// Tokenä¼°ç®—å‡½æ•°
function estimateTokens(text: string, ratio: number): number {
  // ç®€å•ä¼°ç®—ï¼šå­—ç¬¦æ•° / æ¯”ç‡
  // ä¸­æ–‡ï¼š1.5å­—ç¬¦/token
  // è‹±æ–‡ï¼š4å­—ç¬¦/token
  return Math.ceil(text.length / ratio)
}

// APIè°ƒç”¨æ—¶çš„è£å‰ªï¼ˆä¸¥æ ¼é™åˆ¶ï¼‰
export function trimForChatAPI(
  messages: ChatMessage[],
  modelId: string
): ChatMessage[] {
  const config = MESSAGE_LIMITS[modelId] || MESSAGE_LIMITS.default
  const { maxContextTokens, estimateRatio } = config

  let totalTokens = 0
  const trimmedMessages: ChatMessage[] = []

  // ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹å‘å‰éå†
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i]
    const messageTokens = estimateTokens(message.content, estimateRatio)

    // å¦‚æœåŠ ä¸Šè¿™æ¡æ¶ˆæ¯ä¼šè¶…é™ï¼Œåœæ­¢
    if (totalTokens + messageTokens > maxContextTokens) {
      break
    }

    totalTokens += messageTokens
    trimmedMessages.unshift(message) // æ·»åŠ åˆ°å¼€å¤´
  }

  console.log(`[Trimmer] è£å‰ª: ${messages.length} â†’ ${trimmedMessages.length} æ¶ˆæ¯`)
  console.log(`[Trimmer] ä¼°ç®—tokens: ${totalTokens} / ${maxContextTokens}`)

  return trimmedMessages
}

// ç•Œé¢æ˜¾ç¤ºæ—¶çš„è£å‰ªï¼ˆå®½æ¾é™åˆ¶ï¼‰
export function trimForDisplay(
  messages: ChatMessage[],
  modelId: string
): ChatMessage[] {
  // ç±»ä¼¼é€»è¾‘ï¼Œä½†ä½¿ç”¨displayTokensé™åˆ¶
  const config = MESSAGE_LIMITS[modelId] || MESSAGE_LIMITS.default
  // ... çœç•¥å®ç°
}
```

**ç¼–å†™æµ‹è¯•è„šæœ¬ï¼š**
```typescript
// scripts/test-context-trimmer.ts

import { trimForChatAPI } from '../lib/chat/context-trimmer'
import { ChatMessage } from '../types/chat'

function generateTestMessages(count: number): ChatMessage[] {
  const messages: ChatMessage[] = []
  for (let i = 0; i < count; i++) {
    messages.push({
      id: `msg-${i}`,
      role: i % 2 === 0 ? 'user' : 'assistant',
      content: 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯'.repeat(100), // çº¦1000å­—ç¬¦
      status: 'completed',
      createdAt: new Date()
    })
  }
  return messages
}

function testContextTrimmer() {
  console.log('=== ä¸Šä¸‹æ–‡è£å‰ªå™¨æµ‹è¯• ===\n')

  // æµ‹è¯•1ï¼š100æ¡æ¶ˆæ¯è£å‰ª
  console.log('æµ‹è¯•1ï¼š100æ¡æ¶ˆæ¯ï¼ˆæ¯æ¡çº¦1000å­—ç¬¦ï¼‰')
  const messages = generateTestMessages(100)
  const trimmed = trimForChatAPI(messages, 'claude-opus-4')
  console.log(`åŸå§‹: ${messages.length} æ¡`)
  console.log(`è£å‰ªå: ${trimmed.length} æ¡`)
  console.log(`ä¿ç•™æœ€æ–° ${trimmed.length} æ¡æ¶ˆæ¯\n`)

  // æµ‹è¯•2ï¼šçŸ­æ¶ˆæ¯ä¸è£å‰ª
  console.log('æµ‹è¯•2ï¼š10æ¡çŸ­æ¶ˆæ¯')
  const shortMessages = generateTestMessages(10)
  const shortTrimmed = trimForChatAPI(shortMessages, 'claude-opus-4')
  console.log(`åŸå§‹: ${shortMessages.length} æ¡`)
  console.log(`è£å‰ªå: ${shortTrimmed.length} æ¡`)
  console.log('âœ… çŸ­æ¶ˆæ¯ä¸åº”è¢«è£å‰ª\n')

  // æµ‹è¯•3ï¼šä¸åŒæ¨¡å‹é…ç½®
  console.log('æµ‹è¯•3ï¼šä¸åŒæ¨¡å‹çš„è£å‰ªå·®å¼‚')
  const testMessages = generateTestMessages(50)
  const claudeTrimmed = trimForChatAPI(testMessages, 'claude-opus-4')
  const gptTrimmed = trimForChatAPI(testMessages, 'gpt-4')
  console.log(`Claude: ${claudeTrimmed.length} æ¡ï¼ˆé™åˆ¶180k tokensï¼‰`)
  console.log(`GPT-4: ${gptTrimmed.length} æ¡ï¼ˆé™åˆ¶120k tokensï¼‰`)
}

testContextTrimmer()
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šSSEï¼ˆServer-Sent Eventsï¼‰åŸºç¡€

**å­¦ä¹ å†…å®¹ï¼š**
1. SSEåè®®æ ¼å¼
2. SSE vs WebSocket
3. EventSource API
4. é”™è¯¯å¤„ç†å’Œé‡è¿

**æ¨èèµ„æºï¼š**
- MDN SSEæ–‡æ¡£ï¼šhttps://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events

**SSEåè®®æ ¼å¼ï¼š**
```
event: message
data: {"type":"chunk","content":"Hello"}

event: message
data: {"type":"chunk","content":" World"}

event: done
data: {"type":"done"}

[ç©ºè¡Œè¡¨ç¤ºæ¶ˆæ¯ç»“æŸ]
```

**å®è·µä»»åŠ¡ï¼šåˆ›å»ºç®€å•çš„SSEæœåŠ¡**
```typescript
// app/api/test-sse/route.ts

import { NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  // åˆ›å»ºReadableStream
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder()

      // å‘é€å¤šä¸ªäº‹ä»¶
      const messages = ['Hello', ' ', 'World', '!']

      for (const msg of messages) {
        // SSEæ ¼å¼ï¼šdata: å†…å®¹\n\n
        const data = `data: ${JSON.stringify({ content: msg })}\n\n`
        controller.enqueue(encoder.encode(data))

        // æ¨¡æ‹Ÿå»¶è¿Ÿ
        await new Promise(resolve => setTimeout(resolve, 500))
      }

      // å‘é€å®Œæˆäº‹ä»¶
      const done = `data: ${JSON.stringify({ type: 'done' })}\n\n`
      controller.enqueue(encoder.encode(done))

      controller.close()
    }
  })

  // è¿”å›SSEå“åº”
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  })
}
```

**å‰ç«¯æ¶ˆè´¹SSEï¼š**
```typescript
// app/test-sse/page.tsx

'use client'

import { useState } from 'react'

export default function TestSSEPage() {
  const [messages, setMessages] = useState<string[]>([])
  const [isLoading, setIsLoading] = useState(false)

  const handleStart = async () => {
    setIsLoading(true)
    setMessages([])

    try {
      const response = await fetch('/api/test-sse')
      const reader = response.body?.getReader()
      const decoder = new TextDecoder()

      if (!reader) return

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        // è§£ç chunk
        const chunk = decoder.decode(value)
        console.log('æ”¶åˆ°chunk:', chunk)

        // è§£æSSEæ ¼å¼
        const lines = chunk.split('\n')
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6))

            if (data.type === 'done') {
              setIsLoading(false)
            } else if (data.content) {
              setMessages(prev => [...prev, data.content])
            }
          }
        }
      }
    } catch (error) {
      console.error('SSE error:', error)
      setIsLoading(false)
    }
  }

  return (
    <div>
      <h1>SSEæµ‹è¯•</h1>
      <button onClick={handleStart} disabled={isLoading}>
        {isLoading ? 'æ¥æ”¶ä¸­...' : 'å¼€å§‹æ¥æ”¶'}
      </button>
      <div>
        <strong>æ”¶åˆ°çš„æ¶ˆæ¯ï¼š</strong>
        {messages.join('')}
      </div>
    </div>
  )
}
```

**æµ‹è¯•ï¼š**
```bash
# è®¿é—®æµ‹è¯•é¡µé¢
http://localhost:3007/test-sse
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠTokenä¼°ç®—çš„åŸç†
- [ ] èƒ½è§£é‡Šä¸ºä»€ä¹ˆè¦è£å‰ªä¸Šä¸‹æ–‡
- [ ] èƒ½è§£é‡ŠSSEåè®®æ ¼å¼
- [ ] èƒ½åˆ›å»ºç®€å•çš„SSEæœåŠ¡å’Œå®¢æˆ·ç«¯

---

### Day 14ï¼šèŠå¤©APIå®Œæ•´å®ç°ï¼ˆ6å°æ—¶ï¼‰

**é‡è¦æç¤º**ï¼šè¿™æ˜¯Week 2çš„é«˜æ½®éƒ¨åˆ†ï¼åŠ¡å¿…ç†è§£æ¯ä¸€æ­¥ã€‚

### ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰ï¼šèŠå¤©APIè·¯ç”±è¯¦è§£

**å®è·µä»»åŠ¡ï¼š**
```bash
# æ‰“å¼€èŠå¤©APIè·¯ç”±ï¼ˆé¡¹ç›®æœ€æ ¸å¿ƒçš„æ–‡ä»¶ï¼‰
code app/api/chat/route.ts
```

**è¯¦ç»†é˜…è¯»å¹¶æ·»åŠ æ³¨é‡Šï¼ˆè¿™é‡Œåªå±•ç¤ºå…³é”®æ­¥éª¤ï¼‰ï¼š**
```typescript
// app/api/chat/route.ts å®Œæ•´æµç¨‹

import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/auth'
import { quotaManager } from '@/lib/security/quota-manager'
import { trimForChatAPI } from '@/lib/chat/context-trimmer'
import { createSSETransformStream } from '@/lib/utils/sse-parser'

export async function POST(req: NextRequest) {
  try {
    // ===== æ­¥éª¤1ï¼šè®¤è¯éªŒè¯ =====
    const session = await auth()
    if (!session?.user) {
      return NextResponse.json({ error: 'æœªè®¤è¯' }, { status: 401 })
    }
    const userId = session.user.id

    // ===== æ­¥éª¤2ï¼šè§£æè¯·æ±‚ä½“ =====
    const { messages, conversationId, modelId, settings } = await req.json()

    // ===== æ­¥éª¤3ï¼šé…é¢é¢„ç•™ï¼ˆåŸå­æ€§ï¼‰ =====
    const estimatedTokens = estimateRequestTokens(messages)
    await quotaManager.reserveTokens(userId, estimatedTokens)
    console.log(`[Chat API] é¢„ç•™é…é¢: ${estimatedTokens} tokens`)

    // ===== æ­¥éª¤4ï¼šä¸Šä¸‹æ–‡è£å‰ª =====
    const trimmedMessages = trimForChatAPI(messages, modelId)
    console.log(`[Chat API] è£å‰ªæ¶ˆæ¯: ${messages.length} â†’ ${trimmedMessages.length}`)

    // ===== æ­¥éª¤5ï¼šä¿å­˜ç”¨æˆ·æ¶ˆæ¯ =====
    const userMessage = trimmedMessages[trimmedMessages.length - 1]
    await quotaManager.commitTokens(
      userId,
      estimateTokens(userMessage.content),
      0, // ç”¨æˆ·æ¶ˆæ¯æ— é¢„ç•™
      {
        conversationId,
        role: 'user',
        content: userMessage.content,
        userId
      }
    )

    // ===== æ­¥éª¤6ï¼šè°ƒç”¨AI API =====
    const aiResponse = await fetch(AI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`
      },
      body: JSON.stringify({
        model: modelId,
        messages: trimmedMessages.map(m => ({
          role: m.role,
          content: m.content
        })),
        stream: true
      })
    })

    if (!aiResponse.ok) {
      // å¤±è´¥ï¼šé‡Šæ”¾é¢„ç•™é…é¢
      await quotaManager.releaseTokens(userId, estimatedTokens)
      throw new Error('AI APIè°ƒç”¨å¤±è´¥')
    }

    // ===== æ­¥éª¤7ï¼šæµå¼å“åº”å¤„ç† =====
    let fullContent = ''
    let fullReasoning = ''

    const transformStream = createSSETransformStream({
      // æµå¼æ¥æ”¶chunk
      onChunk: (delta: string, reasoning?: string) => {
        fullContent += delta
        if (reasoning) fullReasoning += reasoning
      },

      // å®Œæˆæ—¶ä¿å­˜åŠ©æ‰‹æ¶ˆæ¯
      onComplete: async () => {
        const actualTokens = estimateTokens(fullContent)
        const adjustment = actualTokens - estimatedTokens

        console.log(`[Chat API] å®é™…ä½¿ç”¨: ${actualTokens} tokens`)
        console.log(`[Chat API] è°ƒæ•´é…é¢: ${adjustment} tokens`)

        // ä¿å­˜åŠ©æ‰‹æ¶ˆæ¯å¹¶è°ƒæ•´é…é¢
        await quotaManager.commitTokens(
          userId,
          actualTokens,
          estimatedTokens,
          {
            conversationId,
            role: 'assistant',
            content: fullContent,
            userId,
            metadata: fullReasoning ? { reasoning: fullReasoning } : undefined
          }
        )
      },

      // é”™è¯¯æ—¶å›æ»š
      onError: async (error) => {
        console.error('[Chat API] é”™è¯¯:', error)
        await quotaManager.releaseTokens(userId, estimatedTokens)
      }
    })

    // ===== æ­¥éª¤8ï¼šè¿”å›æµå¼å“åº” =====
    return new Response(
      aiResponse.body!.pipeThrough(transformStream),
      {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive'
        }
      }
    )

  } catch (error) {
    console.error('[Chat API] å¼‚å¸¸:', error)
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    )
  }
}

// è¾…åŠ©å‡½æ•°ï¼šä¼°ç®—è¯·æ±‚token
function estimateRequestTokens(messages: ChatMessage[]): number {
  return messages.reduce((total, msg) => {
    return total + estimateTokens(msg.content, 2)
  }, 0)
}
```

**ç”»å‡ºå®Œæ•´æµç¨‹å›¾ï¼š**
```
POST /api/chat
  â†“
1. è®¤è¯éªŒè¯ (auth())
  â”œâ”€ æˆåŠŸ â†’ è·å–userId
  â””â”€ å¤±è´¥ â†’ 401é”™è¯¯
  â†“
2. è§£æè¯·æ±‚ä½“
  â”œâ”€ messagesï¼ˆæ¶ˆæ¯å†å²ï¼‰
  â”œâ”€ conversationIdï¼ˆå¯¹è¯IDï¼‰
  â”œâ”€ modelIdï¼ˆæ¨¡å‹IDï¼‰
  â””â”€ settingsï¼ˆè®¾ç½®ï¼‰
  â†“
3. é…é¢é¢„ç•™ï¼ˆåŸå­æ€§ï¼‰
  â”œâ”€ estimateRequestTokens() ä¼°ç®—tokens
  â”œâ”€ quotaManager.reserveTokens()
  â”œâ”€ æˆåŠŸ â†’ ç»§ç»­
  â””â”€ å¤±è´¥ â†’ 429é”™è¯¯ï¼ˆé…é¢ä¸è¶³ï¼‰
  â†“
4. ä¸Šä¸‹æ–‡è£å‰ª
  â”œâ”€ trimForChatAPI()
  â””â”€ ä¿ç•™æœ€æ–°Næ¡æ¶ˆæ¯
  â†“
5. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
  â”œâ”€ quotaManager.commitTokens()
  â””â”€ åˆ›å»ºMessageè®°å½•
  â†“
6. è°ƒç”¨AI API
  â”œâ”€ fetch(AI_API_URL, { stream: true })
  â”œâ”€ æˆåŠŸ â†’ è·å–stream
  â””â”€ å¤±è´¥ â†’ releaseTokens() + é”™è¯¯å“åº”
  â†“
7. æµå¼å“åº”å¤„ç†
  â”œâ”€ createSSETransformStream()
  â”œâ”€ onChunk: ç´¯ç§¯content
  â”œâ”€ onComplete: ä¿å­˜åŠ©æ‰‹æ¶ˆæ¯ + è°ƒæ•´é…é¢
  â””â”€ onError: releaseTokens()
  â†“
8. è¿”å›SSEæµ
  â””â”€ Response(stream, { headers: SSE headers })
```

### ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰ï¼šæµ‹è¯•èŠå¤©API

**å®è·µä»»åŠ¡ï¼šç¼–å†™å®Œæ•´æµ‹è¯•**
```typescript
// scripts/test-chat-api.ts

async function testChatAPI() {
  console.log('=== èŠå¤©APIå®Œæ•´æµ‹è¯• ===\n')

  // æ­¥éª¤1ï¼šç™»å½•è·å–session
  console.log('æ­¥éª¤1ï¼šç™»å½•...')
  const loginRes = await fetch('http://localhost:3007/api/auth/signin', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      email: 'test@test.com',
      code: process.env.DEV_LOGIN_CODE
    })
  })
  const cookies = loginRes.headers.get('set-cookie')
  console.log('ç™»å½•æˆåŠŸ')

  // æ­¥éª¤2ï¼šå‘é€èŠå¤©è¯·æ±‚
  console.log('\næ­¥éª¤2ï¼šå‘é€èŠå¤©è¯·æ±‚...')
  const chatRes = await fetch('http://localhost:3007/api/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Cookie': cookies || ''
    },
    body: JSON.stringify({
      messages: [
        { role: 'user', content: 'Hello, how are you?' }
      ],
      conversationId: 'test-conversation',
      modelId: 'claude-3-5-haiku-20241022'
    })
  })

  console.log('å“åº”çŠ¶æ€:', chatRes.status)
  console.log('å“åº”å¤´:', Object.fromEntries(chatRes.headers))

  // æ­¥éª¤3ï¼šè¯»å–æµå¼å“åº”
  console.log('\næ­¥éª¤3ï¼šæ¥æ”¶æµå¼å“åº”...')
  const reader = chatRes.body?.getReader()
  const decoder = new TextDecoder()

  let fullResponse = ''

  if (reader) {
    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value)
      console.log('æ”¶åˆ°chunk:', chunk)

      // è§£æSSEæ ¼å¼
      const lines = chunk.split('\n')
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6))
          if (data.content) {
            fullResponse += data.content
            process.stdout.write(data.content) // å®æ—¶æ˜¾ç¤º
          }
        }
      }
    }
  }

  console.log('\n\næ­¥éª¤4ï¼šå®Œæ•´å“åº”:')
  console.log(fullResponse)

  console.log('\nâœ… æµ‹è¯•å®Œæˆ')
}

testChatAPI().catch(console.error)
```

**è¿è¡Œæµ‹è¯•ï¼š**
```bash
npx tsx scripts/test-chat-api.ts
```

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] èƒ½è§£é‡ŠèŠå¤©APIçš„8ä¸ªå…³é”®æ­¥éª¤
- [ ] èƒ½è§£é‡Šé¢„ç•™-æäº¤-å›æ»šçš„é…é¢ç®¡ç†æ¨¡å¼
- [ ] èƒ½è§£é‡Šæµå¼å“åº”çš„å¤„ç†æµç¨‹
- [ ] èƒ½ç‹¬ç«‹è¿è¡Œå¹¶ç†è§£æµ‹è¯•è„šæœ¬çš„è¾“å‡º

**Week 2 æ€»ç»“ï¼š**
- [ ] æ·±å…¥ç†è§£Prismaå’Œæ•°æ®åº“è®¾è®¡
- [ ] æŒæ¡NextAuthè®¤è¯ç³»ç»Ÿ
- [ ] å®Œå…¨ç†è§£èŠå¤©APIçš„å®Œæ•´é“¾è·¯
- [ ] ç†è§£åŸå­æ€§æ“ä½œå’Œå¹¶å‘æ§åˆ¶

---

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œæˆ‘å°†ç»§ç»­åˆ›å»ºWeek 3-5çš„å­¦ä¹ è®¡åˆ’ã€‚è¦æˆ‘ç»§ç»­å—ï¼Ÿ
