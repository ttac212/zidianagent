/**
 * 修复后的聊天操作 Hook
 * 使用简单的 fetch API，避免复杂的 AI SDK 循环问题
 */

import { useCallback, useRef, useEffect } from 'react'
import { useModelConsistencyCheck } from '@/hooks/use-model-state'
import { toast } from '@/hooks/use-toast'
import { shouldGenerateTitle, generateConversationTitle } from '@/lib/title-utils'
import { fetchWithRetry } from '@/lib/utils/retry'
import { apiMonitor } from '@/lib/monitoring/api-monitor'
import type {
  ChatState,
  ChatAction,
  ChatMessage,
  ChatSettings,
  UseChatActionsReturn,
  Conversation
} from '@/types/chat'

interface UseChatActionsProps {
  state: ChatState
  dispatch: React.Dispatch<ChatAction>
  conversation?: Conversation
  onUpdateConversation?: (id: string, updates: Partial<Conversation>) => void
  getCurrentModel?: () => string // 新增：获取当前模型的函数
  onCreateConversation?: (model?: string) => Promise<Conversation | null> // 新增：创建对话函数
  onSelectConversation?: (id: string) => void // 新增：选择对话函数
}

/**
 * 简化的聊天操作 Hook
 */
export function useChatActionsFixed({
  state,
  dispatch,
  conversation,
  onUpdateConversation,
  getCurrentModel,
  onCreateConversation,
  onSelectConversation
}: UseChatActionsProps): UseChatActionsReturn {

  // 中断控制器引用
  const abortControllerRef = useRef<AbortController | null>(null)
  
  // 模型一致性检查
  const { checkConsistency } = useModelConsistencyCheck('ChatActions')
  
  // 获取发送时的确切模型（优先使用getCurrentModel，fallback到state）
  const getSendingModel = useCallback((): string => {
    const modelFromHook = getCurrentModel ? getCurrentModel() : null
    const modelFromState = state.settings.modelId
    
    // 优先使用统一状态管理的模型
    const actualModel = modelFromHook || modelFromState
    
    // 一致性检查
    if (modelFromHook && modelFromState && modelFromHook !== modelFromState) {
      }
    
    return actualModel
  }, [getCurrentModel, state.settings.modelId])

  /**
   * 发送消息 - 使用简单的 fetch API
   */
  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || state.isLoading) return

    // 检查是否有对话，没有则创建新对话
    let currentConversation: Conversation | undefined = conversation
    if (!currentConversation && onCreateConversation) {
      const modelForNewConversation = getSendingModel()
      const newConversation = await onCreateConversation(modelForNewConversation)
      if (!newConversation) {
        dispatch({ type: 'SET_ERROR', payload: '创建对话失败' })
        return
      }
      currentConversation = newConversation
      // 自动选择新创建的对话
      if (onSelectConversation) {
        onSelectConversation(currentConversation.id)
      }
    }

    // 创建用户消息
    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      content: content.trim(),
      timestamp: Date.now(),
      metadata: { model: getSendingModel() }, // 用户消息也标记使用的模型
    }

    try {
      dispatch({ type: 'SET_LOADING', payload: true })
      dispatch({ type: 'SET_ERROR', payload: null })
      dispatch({ type: 'ADD_MESSAGE', payload: userMessage })

      // 准备消息历史
      const currentMessages = [...state.messages, userMessage]

      // 创建中断控制器
      abortControllerRef.current = new AbortController()

      // 获取发送时的确切模型
      const modelForThisSend = getSendingModel()
      
      // 进行一致性验证
      checkConsistency(
        modelForThisSend, // UI选择的模型
        state.settings.modelId, // 状态中的模型
        modelForThisSend // 请求中使用的模型
      )
      
      : 'N/A',
        '时间戳': new Date().toISOString()
      })
      
      const requestBody = {
        messages: currentMessages.map(m => ({ role: m.role, content: m.content })),
        model: modelForThisSend,
        temperature: state.settings.temperature,
        conversationId: currentConversation?.id, // 使用当前对话的ID（可能是新创建的）
      }
      
      )
      
      // 开始监控API请求
      const requestStartTime = Date.now()
      
      const response = await fetchWithRetry(
        '/api/chat',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
          signal: abortControllerRef.current.signal
        },
        {
          maxRetries: 3,
          initialDelay: 1000,
          onRetry: (error, attempt) => {
            dispatch({ 
              type: 'SET_ERROR', 
              payload: `连接中断，正在重试 (${attempt}/3)...` 
            })
          }
        },
        30000 // 30秒超时
      )

      // 记录API响应
      const requestDuration = Date.now() - requestStartTime
      apiMonitor.logRequest(
        '/api/chat',
        'POST',
        response.status,
        requestDuration,
        response.ok ? undefined : `HTTP ${response.status}`
      )

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`)
      }

      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error('No response body')
      }

      // 创建助手消息（标注使用的模型，便于对齐与回显）
      const assistantMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: '',
        timestamp: Date.now(),
        metadata: { model: modelForThisSend },
      }
      dispatch({ type: 'ADD_MESSAGE', payload: assistantMessage })
      let assistantContent = ''

      // 读取流式响应
      let parseErrorCount = 0
      const maxParseErrors = 5
      
      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = new TextDecoder().decode(value)
        const lines = chunk.split('\n')
        
        for (const line of lines) {
          if (line.startsWith('data: ') && line !== 'data: [DONE]') {
            try {
              const data = JSON.parse(line.slice(6))
              const content = data.choices?.[0]?.delta?.content
              if (content) {
                assistantContent += content
                dispatch({
                  type: 'UPDATE_MESSAGE',
                  payload: {
                    id: assistantMessage.id,
                    updates: { 
                      content: assistantContent 
                    }
                  }
                })
              }
              
              // 检查是否有错误信息
              if (data.error) {
                dispatch({
                  type: 'UPDATE_MESSAGE',
                  payload: {
                    id: assistantMessage.id,
                    updates: { 
                      content: assistantContent + '\n\n[错误: ' + data.error.message + ']',
                      metadata: { ...assistantMessage.metadata, error: data.error.message }
                    }
                  }
                })
                break
              }
            } catch (e) {
              parseErrorCount++
              :`, e, 'Line:', line)
              
              // 如果解析错误过多，通知用户
              if (parseErrorCount >= maxParseErrors) {
                dispatch({
                  type: 'UPDATE_MESSAGE',
                  payload: {
                    id: assistantMessage.id,
                    updates: { 
                      content: assistantContent + '\n\n[注意: 响应解析出现异常，部分内容可能未完整显示]',
                      metadata: { ...assistantMessage.metadata, error: '响应解析异常' }
                    }
                  }
                })
              }
            }
          }
        }
      }

      // 保存到对话记录 - 使用当前对话（可能是新创建的）
      if (currentConversation && onUpdateConversation) {
        const finalAssistantMessage = { ...assistantMessage, content: assistantContent }
        const finalMessages = [...currentMessages, finalAssistantMessage]
        
        // 智能标题更新：检查是否需要生成新标题
        let titleToUpdate = currentConversation.title
        const conversationWithNewMessages = {
          ...currentConversation,
          messages: finalMessages
        }
        
        if (shouldGenerateTitle(conversationWithNewMessages)) {
          const firstUserMessage = finalMessages.find(msg => msg.role === 'user' && msg.content.trim())
          if (firstUserMessage) {
            titleToUpdate = generateConversationTitle(firstUserMessage.content)
            }
        }
        
        // 单次更新：同时更新消息和标题
        onUpdateConversation(currentConversation.id, { 
          messages: finalMessages,
          title: titleToUpdate,
          updatedAt: Date.now() 
        })
        
        // 显示自动保存成功提示
        toast({
          title: "已自动保存",
          description: "对话内容已保存到本地",
          duration: 2000
        })
      }

    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        } else {
        // 提供友好的错误信息
        let userMessage = '发送消息失败'
        if (error instanceof Error) {
          if (error.message.includes('超时')) {
            userMessage = '响应超时，请检查网络连接后重试'
          } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
            userMessage = '网络连接失败，请检查网络设置'
          } else if (error.message.includes('429')) {
            userMessage = '请求过于频繁，请稍后再试'
          } else if (error.message.includes('配额')) {
            userMessage = '月度配额已用完，请联系管理员'
          } else if (error.message.includes('401') || error.message.includes('未认证')) {
            userMessage = '登录已过期，请重新登录'
          } else {
            userMessage = error.message
          }
        }
        
        dispatch({
          type: 'SET_ERROR',
          payload: userMessage
        })
        
        // 显示错误提示
        toast({
          title: "发送失败",
          description: userMessage,
          variant: "destructive",
          duration: 5000
        })
      }
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
      abortControllerRef.current = null
    }
  }, [state.isLoading, state.messages, state.settings, dispatch, conversation, onUpdateConversation, onCreateConversation, onSelectConversation, getSendingModel])

  /**
   * 停止生成
   */
  const stopGeneration = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
    }
    dispatch({ type: 'SET_LOADING', payload: false })
  }, [dispatch])

  /**
   * 复制消息内容
   */
  const copyMessage = useCallback(async (content: string) => {
    try {
      await navigator.clipboard.writeText(content)
      toast({
        title: "复制成功",
        description: "消息内容已复制到剪贴板",
        duration: 1500
      })
    } catch (error) {
      toast({
        title: "复制失败",
        description: "无法访问剪贴板，请手动复制",
        variant: "destructive",
        duration: 3000
      })
    }
  }, [])

  /**
   * 重试消息
   */
  const retryMessage = useCallback(async (messageId: string) => {
    const messageIndex = state.messages.findIndex(msg => msg.id === messageId)
    if (messageIndex === -1) return

    const message = state.messages[messageIndex]
    if (message.role !== 'user') return

    // 移除该消息之后的所有消息
    const messagesToKeep = state.messages.slice(0, messageIndex)
    dispatch({ type: 'CLEAR_MESSAGES' })
    messagesToKeep.forEach(msg => {
      dispatch({ type: 'ADD_MESSAGE', payload: msg })
    })

    // 重新发送消息
    await sendMessage(message.content)
  }, [state.messages, dispatch, sendMessage])

  /**
   * 清空消息
   */
  const clearMessages = useCallback(() => {
    dispatch({ type: 'CLEAR_MESSAGES' })

    // 更新对话记录 - 只有在有对话时才清空
    if (conversation && onUpdateConversation) {
      onUpdateConversation(conversation.id, {
        messages: [],
        updatedAt: Date.now()
      })
    }
  }, [dispatch, conversation, onUpdateConversation])

  /**
   * 更新设置
   */
  const updateSettings = useCallback((newSettings: Partial<ChatSettings>) => {
    dispatch({ type: 'SET_SETTINGS', payload: newSettings })
  }, [dispatch])

  /**
   * 添加快捷操作消息
   */
  const addQuickActionMessage = useCallback((template: string, selectedText?: string) => {
    let content = template
    if (selectedText) {
      content = template.replace('{{selectedText}}', selectedText)
    }
    dispatch({ type: 'SET_INPUT', payload: content })
  }, [dispatch])

  /**
   * 处理模板注入
   */
  const handleTemplateInject = useCallback((template: string) => {
    dispatch({ type: 'SET_INPUT', payload: template })
  }, [dispatch])

  /**
   * 更新消息状态（用于流式响应）
   */
  const updateMessageStatus = useCallback((messageId: string, updates: Partial<ChatMessage>) => {
    dispatch({
      type: 'UPDATE_MESSAGE',
      payload: { id: messageId, updates }
    })
  }, [dispatch])

  /**
   * 处理错误重试
   */
  const handleErrorRetry = useCallback(async () => {
    if (!state.error) return

    dispatch({ type: 'SET_ERROR', payload: null })

    // 如果有输入内容，重新发送
    if (state.input.trim()) {
      await sendMessage(state.input)
    }
  }, [state.error, state.input, dispatch, sendMessage])

  /**
   * 批量操作
   */
  const batchOperations = {
    // 导入消息
    importMessages: useCallback((messages: ChatMessage[]) => {
      dispatch({ type: 'CLEAR_MESSAGES' })
      messages.forEach(msg => {
        dispatch({ type: 'ADD_MESSAGE', payload: msg })
      })
    }, [dispatch]),

    // 导出消息
    exportMessages: useCallback(() => {
      return state.messages.map(msg => ({
        role: msg.role,
        content: msg.content,
        timestamp: msg.timestamp
      }))
    }, [state.messages]),

    // 搜索消息
    searchMessages: useCallback((query: string) => {
      return state.messages.filter(msg =>
        msg.content.toLowerCase().includes(query.toLowerCase())
      )
    }, [state.messages])
  }

  return {
    sendMessage,
    stopGeneration,
    copyMessage,
    retryMessage,
    clearMessages,
    updateSettings,
    addQuickActionMessage,
    handleTemplateInject,
    updateMessageStatus,
    handleErrorRetry,
    batchOperations
  }
}

/**
 * 快捷操作配置
 */
export const QUICK_ACTIONS = [
  {
    id: 'optimize',
    label: '优化文本',
    template: '请帮我优化这段文本：\n\n"{{selectedText}}"\n\n',
    shortcut: 'Ctrl+1'
  },
  {
    id: 'expand',
    label: '扩展内容',
    template: '请帮我扩展这段内容：\n\n"{{selectedText}}"\n\n',
    shortcut: 'Ctrl+2'
  },
  {
    id: 'summarize',
    label: '总结内容',
    template: '请帮我总结这段文本：\n\n"{{selectedText}}"\n\n',
    shortcut: 'Ctrl+3'
  },
  {
    id: 'translate',
    label: '翻译文本',
    template: '请帮我翻译这段文本：\n\n"{{selectedText}}"\n\n',
    shortcut: 'Ctrl+4'
  }
] as const