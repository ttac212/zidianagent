"use client"

import { useState, useEffect, useCallback } from "react"
import { DEFAULT_MODEL } from "@/lib/ai/models"
import type { ChatMessage, Conversation } from "@/types/chat"
import { LocalStorage, STORAGE_KEYS } from "@/lib/storage"

// ä¸ºäº†å…¼å®¹æ€§ï¼Œæš‚æ—¶ä¿ç•™ Message ç±»å‹åˆ«å
export type Message = ChatMessage

// API å“åº”ç±»å‹
interface ConversationResponse {
  id: string
  title: string
  modelId: string
  temperature: number
  maxTokens: number
  messageCount: number
  totalTokens: number
  createdAt: string
  updatedAt: string
  lastMessageAt: string | null
  messages?: MessageResponse[]
}

interface MessageResponse {
  id: string
  role: 'USER' | 'ASSISTANT' | 'SYSTEM' | 'FUNCTION'
  content: string
  modelId: string | null
  temperature: number | null
  promptTokens: number
  completionTokens: number
  totalTokens: number
  finishReason: string | null
  metadata: any
  createdAt: string
}

// è½¬æ¢ API å“åº”ä¸ºå‰ç«¯æ ¼å¼
function apiToConversation(apiConv: ConversationResponse): Conversation {
  return {
    id: apiConv.id,
    title: apiConv.title,
    messages: apiConv.messages?.map(msg => ({
      id: msg.id,
      role: msg.role.toLowerCase() as ChatMessage['role'],
      content: msg.content,
      timestamp: new Date(msg.createdAt).getTime(),
      tokens: msg.totalTokens || undefined,
      metadata: {
        ...msg.metadata,
        // ç¡®ä¿ä»æ•°æ®åº“çš„modelIdå­—æ®µæ˜ å°„åˆ°metadata.model
        model: msg.modelId || msg.metadata?.model,
        temperature: msg.temperature || msg.metadata?.temperature,
        processingTime: msg.metadata?.processingTime
      }
    })) || [],
    model: apiConv.modelId,
    createdAt: new Date(apiConv.createdAt).getTime(),
    updatedAt: new Date(apiConv.updatedAt).getTime(),
  }
}

export function useConversations() {
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(() => {
    // ä» localStorage æ¢å¤ä¸Šæ¬¡é€‰ä¸­çš„å¯¹è¯ID
    try {
      return LocalStorage.getItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, null)
    } catch (error) {
      return null
    }
  })
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [loadingConversationId, setLoadingConversationId] = useState<string | null>(null)
  
  // ğŸ”’ æ“ä½œé”çŠ¶æ€ç®¡ç† - é˜²æ­¢ç«æ€æ¡ä»¶
  const [operationLocks, setOperationLocks] = useState<Set<string>>(new Set())
  const [pendingOperations, setPendingOperations] = useState<Map<string, number>>(new Map())

  // ä»åç«¯åŠ è½½å¯¹è¯åˆ—è¡¨
  const loadConversations = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      
      const response = await fetch('/api/conversations?limit=100')
      if (!response.ok) {
        if (response.status === 401) {
          // ç”¨æˆ·æœªç™»å½•ï¼Œè¿”å›ç©ºåˆ—è¡¨
          setConversations([])
          return
        }
        throw new Error(`Failed to load conversations: ${response.status}`)
      }

      const data = await response.json()
      if (data.success && data.data) {
        const convs = data.data.conversations.map(apiToConversation)
        setConversations(convs)
        
        // æ™ºèƒ½é€‰æ‹©å½“å‰å¯¹è¯
        if (convs.length > 0) {
          let targetConversationId: string | null = null
          
          // 1. ä¼˜å…ˆä½¿ç”¨å·²æ¢å¤çš„å¯¹è¯IDï¼ˆå¦‚æœå­˜åœ¨äºå¯¹è¯åˆ—è¡¨ä¸­ï¼‰
          if (currentConversationId && convs.find((c: Conversation) => c.id === currentConversationId)) {
            targetConversationId = currentConversationId
            }
          // 2. å¦‚æœæ²¡æœ‰å·²é€‰å¯¹è¯æˆ–å·²é€‰å¯¹è¯ä¸å­˜åœ¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯¹è¯
          else if (!currentConversationId) {
            targetConversationId = convs[0].id
            // ä¿å­˜æ–°é€‰æ‹©çš„å¯¹è¯ID
            setCurrentConversationId(targetConversationId)
            LocalStorage.setItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, targetConversationId)
          }
          // 3. å¦‚æœå·²é€‰å¯¹è¯ä¸å­˜åœ¨ï¼Œæ¸…é™¤æ— æ•ˆçš„é€‰æ‹©å¹¶é€‰æ‹©ç¬¬ä¸€ä¸ª
          else {
            targetConversationId = convs[0].id
            setCurrentConversationId(targetConversationId)
            LocalStorage.setItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, targetConversationId)
          }
          
          // å¼‚æ­¥åŠ è½½ç›®æ ‡å¯¹è¯çš„è¯¦æƒ…
          if (targetConversationId) {
            loadConversationDetail(targetConversationId).then(detailConv => {
              if (detailConv) {
                }
            })
          }
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'åŠ è½½å¯¹è¯å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }, [currentConversationId])

  // åŠ è½½å•ä¸ªå¯¹è¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…å«æ¶ˆæ¯ï¼‰
  const loadConversationDetail = useCallback(async (id: string): Promise<Conversation | null> => {
    try {
      setLoadingConversationId(id)
      
      const response = await fetch(`/api/conversations/${id}?includeMessages=true`)
      if (!response.ok) {
        if (response.status === 404) {
          // å¯¹è¯ä¸å­˜åœ¨ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤
          setConversations(prev => prev.filter(c => c.id !== id))
          if (currentConversationId === id) {
            setCurrentConversationId(null)
          }
          return null
        }
        throw new Error(`Failed to load conversation: ${response.status}`)
      }

      const data = await response.json()
      if (data.success && data.data) {
        const conv = apiToConversation(data.data)
        // æ›´æ–°å¯¹è¯åˆ—è¡¨ä¸­çš„è¿™ä¸ªå¯¹è¯
        setConversations(prev => {
          const index = prev.findIndex(c => c.id === id)
          if (index >= 0) {
            const updated = [...prev]
            updated[index] = conv
            return updated
          } else {
            return [conv, ...prev]
          }
        })
        
        return conv
      }
      return null
    } catch (err) {
      setError(err instanceof Error ? err.message : 'åŠ è½½å¯¹è¯è¯¦æƒ…å¤±è´¥')
      return null
    } finally {
      setLoadingConversationId(null)
    }
  }, [currentConversationId])

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadConversations()
  }, [])

  // åˆ›å»ºæ–°å¯¹è¯
  const createConversation = useCallback(
    async (model = DEFAULT_MODEL) => {
      try {
        const response = await fetch('/api/conversations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: 'æ–°å¯¹è¯',
            modelId: model,
            temperature: 0.7,
            maxTokens: 2000,
            contextAware: true
          })
        })

        if (!response.ok) {
          if (response.status === 401) {
            setError('è¯·å…ˆç™»å½•')
            return null
          }
          throw new Error(`Failed to create conversation: ${response.status}`)
        }

        const data = await response.json()
        if (data.success && data.data) {
          const newConversation = apiToConversation(data.data)
          
          setConversations(prev => [newConversation, ...prev])
          setCurrentConversationId(newConversation.id)
          
          // æŒä¹…åŒ–æ–°åˆ›å»ºçš„å¯¹è¯é€‰æ‹©
          try {
            LocalStorage.setItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, newConversation.id)
            } catch (error) {
            }
          
          return newConversation
        }
        return null
      } catch (err) {
        setError(err instanceof Error ? err.message : 'åˆ›å»ºå¯¹è¯å¤±è´¥')
        return null
      }
    },
    []
  )

  // ğŸ”’ æ“ä½œé”ç®¡ç†è¾…åŠ©å‡½æ•°
  const acquireLock = useCallback((operationKey: string): boolean => {
    if (operationLocks.has(operationKey)) {
      return false
    }
    
    setOperationLocks(prev => new Set([...prev, operationKey]))
    return true
  }, [operationLocks])

  const releaseLock = useCallback((operationKey: string) => {
    setOperationLocks(prev => {
      const next = new Set(prev)
      next.delete(operationKey)
      return next
    })
    
    // æ¸…ç†å¾…å¤„ç†è®¡æ•°
    setPendingOperations(prev => {
      const next = new Map(prev)
      next.delete(operationKey)
      return next
    })
  }, [])

  const incrementPendingCount = useCallback((operationKey: string) => {
    setPendingOperations(prev => {
      const next = new Map(prev)
      const current = next.get(operationKey) || 0
      next.set(operationKey, current + 1)
      return next
    })
  }, [])

  // ğŸ”’ é˜²ç«æ€æ¡ä»¶çš„æ›´æ–°å¯¹è¯å‡½æ•°
  const updateConversation = useCallback(
    async (id: string, updates: Partial<Conversation>) => {
      const operationKey = `update-${id}`
      
      // æ£€æŸ¥æ“ä½œé”
      if (!acquireLock(operationKey)) {
        incrementPendingCount(operationKey)
        return // è·³è¿‡é‡å¤æ“ä½œ
      }

      try {
        // åªå‘é€åç«¯æ”¯æŒçš„å­—æ®µ
        const apiUpdates: any = {}
        if (updates.title !== undefined) apiUpdates.title = updates.title
        if (updates.model !== undefined) apiUpdates.modelId = updates.model
        
        const response = await fetch(`/api/conversations/${id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(apiUpdates)
        })

        if (!response.ok) {
          throw new Error(`Failed to update conversation: ${response.status}`)
        }

        const data = await response.json()
        if (data.success && data.data) {
          const updatedConv = apiToConversation(data.data)
          
          setConversations(prev => {
            const updatedConversations = prev.map(conv =>
              conv.id === id ? { 
                ...conv, 
                ...updatedConv,
                // ğŸ›¡ï¸ ä¿æŠ¤messageså­—æ®µï¼šå¦‚æœAPIè¿”å›ç©ºæ¶ˆæ¯ï¼Œä¿æŒåŸæœ‰æ¶ˆæ¯
                messages: updatedConv.messages && updatedConv.messages.length > 0 
                  ? updatedConv.messages 
                  : conv.messages
              } : conv
            )
            
            ?.messages?.length || 0)
            
            return updatedConversations
          })
          
          }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'æ›´æ–°å¯¹è¯å¤±è´¥')
      } finally {
        // å§‹ç»ˆé‡Šæ”¾é”
        releaseLock(operationKey)
      }
    },
    [acquireLock, releaseLock, incrementPendingCount]
  )

  // ğŸ”’ é˜²ç«æ€æ¡ä»¶çš„åˆ é™¤å¯¹è¯å‡½æ•°
  const deleteConversation = useCallback(
    async (id: string) => {
      const operationKey = `delete-${id}`
      
      // æ£€æŸ¥æ“ä½œé”
      if (!acquireLock(operationKey)) {
        incrementPendingCount(operationKey)
        return // è·³è¿‡é‡å¤æ“ä½œ
      }

      try {
        const response = await fetch(`/api/conversations/${id}`, {
          method: 'DELETE'
        })

        if (!response.ok) {
          throw new Error(`Failed to delete conversation: ${response.status}`)
        }

        setConversations(prev => prev.filter(conv => conv.id !== id))
        
        if (currentConversationId === id) {
          const remaining = conversations.filter(c => c.id !== id)
          const newCurrentId = remaining.length > 0 ? remaining[0].id : null
          setCurrentConversationId(newCurrentId)
          
          // æŒä¹…åŒ–åˆ é™¤åçš„å¯¹è¯é€‰æ‹©
          try {
            if (newCurrentId) {
              LocalStorage.setItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, newCurrentId)
              } else {
              LocalStorage.removeItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID)
              }
          } catch (error) {
            }
        }
        
        } catch (err) {
        setError(err instanceof Error ? err.message : 'åˆ é™¤å¯¹è¯å¤±è´¥')
      } finally {
        // å§‹ç»ˆé‡Šæ”¾é”
        releaseLock(operationKey)
      }
    },
    [conversations, currentConversationId, acquireLock, releaseLock, incrementPendingCount]
  )

  // è®¾ç½®å½“å‰å¯¹è¯ - æ”¹è¿›ç‰ˆï¼Œç¡®ä¿æ­£ç¡®å¤„ç†æ¶ˆæ¯åŠ è½½å’ŒæŒä¹…åŒ–
  const setCurrentConversation = useCallback(
    async (id: string | null) => {
      // å¦‚æœæ˜¯ç›¸åŒå¯¹è¯ï¼Œä¸éœ€è¦é‡å¤åŠ è½½
      if (id === currentConversationId) {
        return
      }
      
      // ç«‹å³è®¾ç½®å½“å‰å¯¹è¯IDï¼Œä»¥ä¾¿UIèƒ½å¤Ÿç«‹å³å“åº”
      setCurrentConversationId(id)
      
      // æŒä¹…åŒ–å½“å‰å¯¹è¯é€‰æ‹©
      try {
        if (id) {
          LocalStorage.setItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID, id)
          } else {
          LocalStorage.removeItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID)
          }
      } catch (error) {
        }
      
      // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯çŠ¶æ€
      setError(null)
      
      // å¦‚æœé€‰æ‹©äº†å¯¹è¯ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½è¯¦ç»†ä¿¡æ¯
      if (id) {
        const existingConv = conversations.find(c => c.id === id)
        
        // å¦‚æœå¯¹è¯å­˜åœ¨ä½†æ²¡æœ‰æ¶ˆæ¯æˆ–æ¶ˆæ¯æ•°é‡ä¸º0ï¼Œåˆ™åŠ è½½è¯¦ç»†ä¿¡æ¯
        if (!existingConv || !existingConv.messages || existingConv.messages.length === 0) {
          const detailConv = await loadConversationDetail(id)
          if (detailConv) {
            } else {
            // å¦‚æœåŠ è½½å¤±è´¥ï¼Œæ¢å¤åˆ°nullçŠ¶æ€å¹¶æ¸…é™¤localStorage
            setCurrentConversationId(null)
            try {
              LocalStorage.removeItem(STORAGE_KEYS.CURRENT_CONVERSATION_ID)
            } catch (error) {
              }
          }
        } else {
          }
      }
    },
    [currentConversationId, conversations, loadConversationDetail]
  )

  // è·å–å½“å‰å¯¹è¯
  const getCurrentConversation = useCallback(() => {
    if (!currentConversationId) return null
    return conversations.find((conv) => conv.id === currentConversationId) || null
  }, [conversations, currentConversationId])

  // æ›´æ–°å¯¹è¯æ¶ˆæ¯ï¼ˆæœ¬åœ°æ›´æ–°ï¼Œç”¨äºèŠå¤©æ—¶çš„å³æ—¶å“åº”ï¼‰
  const updateConversationMessages = useCallback(
    (id: string, messages: ChatMessage[]) => {
      setConversations(prev => prev.map(conv =>
        conv.id === id ? { ...conv, messages, updatedAt: Date.now() } : conv
      ))
    },
    []
  )

  // æ›´æ–°å¯¹è¯ï¼ˆåŒ…å«æ¶ˆæ¯ï¼‰- æ”¹è¿›ç‰ˆæœ¬ï¼Œæ”¯æŒæ¶ˆæ¯æ›´æ–°
  const updateConversationWithMessages = useCallback(
    async (id: string, updates: Partial<Conversation>) => {
      // å¦‚æœåªæ˜¯æ›´æ–°æ¶ˆæ¯ï¼Œç›´æ¥æœ¬åœ°æ›´æ–°ï¼ˆå› ä¸ºæ¶ˆæ¯å·²ç»åœ¨åç«¯ä¿å­˜äº†ï¼‰
      if (updates.messages && Object.keys(updates).length === 2 && updates.updatedAt) {
        setConversations(prev => prev.map(conv =>
          conv.id === id ? { ...conv, messages: updates.messages!, updatedAt: updates.updatedAt! } : conv
        ))
        return
      }

      // å…¶ä»–æ›´æ–°èµ°åŸæ¥çš„ API æ›´æ–°é€»è¾‘
      await updateConversation(id, updates)
    },
    [updateConversation]
  )

  return {
    conversations,
    currentConversationId,
    loading,
    error,
    loadingConversationId, // å¯¼å‡ºåŠ è½½ä¸­çš„å¯¹è¯ID
    createConversation,
    updateConversation,
    updateConversationWithMessages, // å¯¼å‡ºæ–°çš„æ›´æ–°å‡½æ•°
    deleteConversation,
    setCurrentConversation,
    getCurrentConversation,
    updateConversationMessages,
    refreshConversations: loadConversations,
    
    // ğŸ”’ æ“ä½œçŠ¶æ€å¯¼å‡º - ç”¨äºUIåé¦ˆ
    operationLocks,
    pendingOperations,
    isOperationLocked: (operationKey: string) => operationLocks.has(operationKey),
    getPendingCount: (operationKey: string) => pendingOperations.get(operationKey) || 0,
  }
}